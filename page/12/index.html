<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Redis">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis文档">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="Redis文档">
<meta property="og:description" content="Redis">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis文档">
<meta name="twitter:description" content="Redis">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/12/"/>





  <title>Redis文档</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Redis文档</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Redis在Java上的使用手册</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/decrby/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/decrby/" itemprop="url">decrby</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T16:25:58+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>支持版本: &gt;= 1.0.0</li>
<li>时间复杂度: O(1)</li>
<li>返回值: Integers,减小之后的value</li>
</ul>
<h3 id="redis-cli-例子"><a href="#redis-cli-例子" class="headerlink" title="redis-cli 例子"></a>redis-cli 例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"10"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECRBY mykey 5</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
<h3 id="SpringBoot-例子"><a href="#SpringBoot-例子" class="headerlink" title="SpringBoot 例子"></a>SpringBoot 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"key不存在的测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyNotExistTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line"></span><br><span class="line">    String testKey = String.format(<span class="string">"testKey:%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span>(testKeySerializeBytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"testKey异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Long executeResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.decrBy(testKeySerializeBytes, <span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">"decrBy executeResult:&#123;&#125;"</span>, executeResult);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"key存在的测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyExistTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer();</span><br><span class="line"></span><br><span class="line">    String testKey = String.format(<span class="string">"testKey:%s"</span>, UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span>(testKeySerializeBytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"testKey异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置testKey的值为123</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(testKey,<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// decrBy 1</span></span><br><span class="line">        Long executeResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.decrBy(testKeySerializeBytes, <span class="number">1</span>));</span><br><span class="line">        logger.info(<span class="string">"decrBy executeResult:&#123;&#125;"</span>, executeResult);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/distlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/distlock/" itemprop="url">Redis分布式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T15:41:37+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>分布式锁在很多场景中是非常有用的原语， 不同的进程必须以独占资源的方式实现资源共享就是一个典型的例子。</p>
<p>有很多分布式锁的库和描述怎么实现分布式锁管理器（DLM)的博客,但是每个库的实现方式都不太一样，很多库的实现方式为了简单降低了可靠性，而有的使用了稍微复杂的设计。</p>
<p>这个页面试图提供一个使用Redis实现分布式锁的规范算法。我们提出一种算法，叫Redlock,我们认为这种实现比普通的单实例实现更安全,我们希望redis社区能帮助分析一下这种实现方法，并给我们提供反馈。</p>
<h3 id="安全和活性失效保障"><a href="#安全和活性失效保障" class="headerlink" title="安全和活性失效保障"></a>安全和活性失效保障</h3><p>按照我们的思路和设计方案，算法只需具备3个特性就可以实现一个最低保障的分布式锁。</p>
<ul>
<li>安全属性（Safety property）: 独享（相互排斥）。在任意一个时刻，只有一个客户端持有锁。</li>
<li>活性A(Liveness property A): 无死锁。即便持有锁的客户端崩溃（crashed)或者网络被分裂（gets partitioned)，锁仍然可以被获取。</li>
<li>活性B(Liveness property B): 容错。 只要大部分Redis节点都活着，客户端就可以获取和释放锁.</li>
</ul>
<h3 id="为什么基于故障转移的实现还不够"><a href="#为什么基于故障转移的实现还不够" class="headerlink" title="为什么基于故障转移的实现还不够"></a>为什么基于故障转移的实现还不够</h3><p>为了更好的理解我们想要改进的方面，我们先分析一下当前大多数基于Redis的分布式锁现状和实现方法.</p>
<p>实现Redis分布式锁的最简单的方法就是在Redis中创建一个key，这个key有一个失效时间（TTL)，以保证锁最终会被自动释放掉（这个对应特性2）。当客户端释放资源(解锁）的时候，会删除掉这个key。</p>
<p>从表面上看，似乎效果还不错，但是这里有一个问题：这个架构中存在一个严重的单点失败问题。如果Redis挂了怎么办？你可能会说，可以通过增加一个slave节点解决这个问题。但这通常是行不通的。这样做，我们不能实现资源的独享,因为Redis的主从同步通常是异步的。</p>
<p>在这种场景（主从结构）中存在明显的竞态:</p>
<ul>
<li>客户端A从master获取到锁</li>
<li>在master将锁同步到slave之前，master宕掉了。</li>
<li>slave节点被晋级为master节点</li>
<li>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！</li>
</ul>
<p>有时候程序就是这么巧，比如说正好一个节点挂掉的时候，多个客户端同时取到了锁。如果你可以接受这种小概率错误，那用这个基于复制的方案就完全没有问题。否则的话，我们建议你实现下面描述的解决方案。</p>
<h3 id="单Redis实例实现分布式锁的正确方法"><a href="#单Redis实例实现分布式锁的正确方法" class="headerlink" title="单Redis实例实现分布式锁的正确方法"></a>单Redis实例实现分布式锁的正确方法</h3><p>在尝试克服上述单实例设置的限制之前，让我们先讨论一下在这种简单情况下实现分布式锁的正确做法，实际上这是一种可行的方案，尽管存在竞态，结果仍然是可接受的，另外，这里讨论的单实例加锁方法也是分布式加锁算法的基础。</p>
<p>获取锁使用命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure></p>
<p>这个命令仅在不存在key的时候才能被执行成功（NX选项），并且这个key有一个30秒的自动失效时间（PX属性）。这个key的值是“my_random_value”(一个随机值），这个值在所有的客户端必须是唯一的，所有同一key的获取者（竞争者）这个值都不能一样。</p>
<p>value的值必须是随机数主要是为了更安全的释放锁，释放锁的时候使用脚本告诉Redis:只有key存在并且存储的值和我指定的值一样才能告诉我删除成功。可以通过以下Lua脚本实现：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>使用这种方式释放锁可以避免删除别的客户端获取成功的锁。举个例子：客户端A取得资源锁，但是紧接着被一个其他操作阻塞了，当客户端A运行完毕其他操作后要释放锁时，原来的锁早已超时并且被Redis自动释放，并且在这期间资源锁又被客户端B再次获取到。如果仅使用DEL命令将key删除，那么这种情况就会把客户端B的锁给删除掉。使用Lua脚本就不会存在这种情况，因为脚本仅会删除value等于客户端A的value的key（value相当于客户端的一个签名）。</p>
<p>这个随机字符串应该怎么设置？我认为它应该是从/dev/urandom产生的一个20字节随机数，但是我想你可以找到比这种方法代价更小的方法，只要这个数在你的任务中是唯一的就行。例如一种安全可行的方法是使用/dev/urandom作为RC4的种子和源产生一个伪随机流;一种更简单的方法是把以毫秒为单位的unix时间和客户端ID拼接起来，理论上不是完全安全，但是在多数情况下可以满足需求.</p>
<p>key的失效时间，被称作“锁定有效期”。它不仅是key自动失效时间，而且还是一个客户端持有锁多长时间后可以被另外一个客户端重新获得。</p>
<p>截至到目前，我们已经有较好的方法获取锁和释放锁。基于Redis单实例，假设这个单实例总是可用，这种方法已经足够安全。现在让我们扩展一下，假设Redis没有总是可用的保障。</p>
<h3 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h3><p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<ul>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</li>
</ul>
<h3 id="这个算法是异步的么"><a href="#这个算法是异步的么" class="headerlink" title="这个算法是异步的么?"></a>这个算法是异步的么?</h3><p>算法基于这样一个假设：虽然多个进程之间没有时钟同步，但每个进程都以相同的时钟频率前进，时间差相对于失效时间来说几乎可以忽略不计。这种假设和我们的真实世界非常接近：每个计算机都有一个本地时钟，我们可以容忍多个计算机之间有较小的时钟漂移。</p>
<p>从这点来说，我们必须再次强调我们的互相排斥规则：只有在锁的有效时间（在步骤3计算的结果）范围内客户端能够做完它的工作，锁的安全性才能得到保证（锁的实际有效时间通常要比设置的短，因为计算机之间有时钟漂移的现象）。</p>
<h3 id="失败时重试"><a href="#失败时重试" class="headerlink" title="失败时重试"></a>失败时重试</h3><p>当客户端无法取到锁时，应该在一个随机延迟后重试,防止多个客户端在同时抢夺同一资源的锁（这样会导致脑裂，没有人会取到锁）。同样，客户端取得大部分Redis实例锁所花费的时间越短，脑裂出现的概率就会越低（必要的重试），所以，理想情况一下，客户端应该同时（并发地）向所有Redis发送SET命令。</p>
<p>需要强调，当客户端从大多数Redis实例获取锁失败时，应该尽快地释放（部分）已经成功取到的锁，这样其他的客户端就不必非得等到锁过完“有效时间”才能取到（然而，如果已经存在网络分裂，客户端已经无法和Redis实例通信，此时就只能等待key的自动释放了，等于被惩罚了）。</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁比较简单，向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁.</p>
<h3 id="安全争议"><a href="#安全争议" class="headerlink" title="安全争议"></a>安全争议</h3><p>这个算法安全么？我们可以从不同的场景讨论一下。</p>
<p>让我们假设客户端从大多数Redis实例取到了锁。所有的实例都包含同样的key，并且key的有效时间也一样。然而，key肯定是在不同的时间被设置上的，所以key的失效时间也不是精确的相同。我们假设第一个设置的key时间是T1(开始向第一个server发送命令前时间），最后一个设置的key时间是T2(得到最后一台server的答复后的时间），我们可以确认，第一个server的key至少会存活 MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT。所有其他的key的存活时间，都会比这个key时间晚，所以可以肯定，所有key的失效时间至少是MIN_VALIDITY。</p>
<p>当大部分实例的key被设置后，其他的客户端将不能再取到锁，因为至少N/2+1个实例已经存在key。所以，如果一个锁被（客户端）获取后，客户端自己也不能再次申请到锁(违反互相排斥属性）。</p>
<p>然而我们也想确保，当多个客户端同时抢夺一个锁时不能两个都成功。</p>
<p>如果客户端在获取到大多数redis实例锁，使用的时间接近或者已经大于失效时间，客户端将认为锁是失效的锁，并且将释放掉已经获取到的锁，所以我们只需要在有效时间范围内获取到大部分锁这种情况。在上面已经讨论过有争议的地方，在MIN_VALIDITY时间内，将没有客户端再次取得锁。所以只有一种情况，多个客户端会在相同时间取得N/2+1实例的锁，那就是取得锁的时间大于失效时间（TTL time)，这样取到的锁也是无效的.</p>
<p>如果你能提供关于现有的类似算法的一个正式证明（指出正确性），或者是发现这个算法的bug？ 我们将非常感激.</p>
<h3 id="活性争议"><a href="#活性争议" class="headerlink" title="活性争议"></a>活性争议</h3><p>系统的活性安全基于三个主要特性:</p>
<ul>
<li>锁的自动释放（因为key失效了）：最终锁可以再次被使用.</li>
<li>客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端会主动（提前）释放锁，而不是等到锁失效另外的客户端才能取到锁。.</li>
<li>当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取锁使用的时间，以最大限度地避免脑裂。.<br>然而，当网络出现问题时系统在失效时间(TTL)内就无法服务，这种情况下我们的程序就会为此付出代价。如果网络持续的有问题，可能就会出现死循环了。 这种情况发生在当客户端刚取到一个锁还没有来得及释放锁就被网络隔离.<br>如果网络一直没有恢复，这个算法会导致系统不可用.</li>
</ul>
<h3 id="性能，崩溃恢复和Redis同步"><a href="#性能，崩溃恢复和Redis同步" class="headerlink" title="性能，崩溃恢复和Redis同步"></a>性能，崩溃恢复和Redis同步</h3><p>很多用户把Redis当做分布式锁服务器，使用获取锁和释放锁的响应时间，每秒钟可用执行多少次 acquire / release 操作作为性能指标。为了达到这一要求，增加Redis实例当然可用降低响应延迟（没有钱买硬件的”穷人”,也可以在网络方面做优化，使用非阻塞模型，一次发送所有的命令，然后异步的读取响应结果，假设客户端和redis服务器之间的RTT都差不多。</p>
<p>然而，如果我们想使用可以从备份中恢复的redis模式，有另外一种持久化情况你需要考虑，.</p>
<p>我们考虑这样一种场景，假设我们的redis没用使用备份。一个客户端获取到了3个实例的锁。此时，其中一个已经被客户端取到锁的redis实例被重启，在这个时间点，就可能出现3个节点没有设置锁，此时如果有另外一个客户端来设置锁，锁就可能被再次获取到，这样锁的互相排斥的特性就被破坏掉了。</p>
<p>如果我们启用了AOF持久化，情况会好很多。我们可用使用SHUTDOWN命令关闭然后再次重启。因为Redis到期是语义上实现的，所以当服务器关闭时，实际上还是经过了时间，所有（保持锁）需要的条件都没有受到影响. 没有受到影响的前提是redis优雅的关闭。停电了怎么办？如果redis是每秒执行一次fsync，那么很有可能在redis重启之后，key已经丢弃。理论上，如果我们想在Redis重启地任何情况下都保证锁的安全，我们必须开启fsync=always的配置。这反过来将完全破坏与传统上用于以安全的方式实现分布式锁的同一级别的CP系统的性能.</p>
<p>然而情况总比一开始想象的好一些。当一个redis节点重启后，只要它不参与到任意当前活动的锁，没有被当做“当前存活”节点被客户端重新获取到,算法的安全性仍然是有保障的。</p>
<p>为了达到这种效果，我们只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放.</p>
<p>使用延迟重启可以在不采用持久化策略的情况下达到同样的安全，然而这样做有时会让系统转化为彻底不可用。比如大部分的redis实例都崩溃了，系统在TTL时间内任何锁都将无法加锁成功。</p>
<h3 id="使算法更加可靠：锁的扩展"><a href="#使算法更加可靠：锁的扩展" class="headerlink" title="使算法更加可靠：锁的扩展"></a>使算法更加可靠：锁的扩展</h3><p>如果你的工作可以拆分为许多小步骤，可以将有效时间设置的小一些，使用锁的一些扩展机制。在工作进行的过程中，当发现锁剩下的有效时间很短时，可以再次向redis的所有实例发送一个Lua脚本，让key的有效时间延长一点（前提还是key存在并且value是之前设置的value)。</p>
<p>客户端扩展TTL时必须像首次取得锁一样在大多数实例上扩展成功才算再次取到锁，并且是在有效时间内再次取到锁（算法和获取锁是非常相似的）。</p>
<p>这样做从技术上将并不会改变算法的正确性，所以扩展锁的过程中仍然需要达到获取到N/2+1个实例这个要求，否则活性特性之一就会失效。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/transactions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/transactions/" itemprop="url">事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T15:57:34+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>EXEC 命令负责触发并执行事务中的所有命令：</p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</li>
</ul>
<p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p>
<p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p>
<p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p>
<p>使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
<p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure></p>
<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li>
</ul>
<p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p>
<p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p>
<p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p>
<p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p>
<p>EXEC 返回两条bulk-string-reply： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p>
<p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p>
<p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line">INCR a b c</span><br><span class="line">-ERR wrong number of arguments for &apos;incr&apos; command</span><br></pre></td></tr></table></figure>
<p>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</p>
<h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</p>
<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">&gt; GET foo</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</p>
<p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。</p>
<p>首先我们可能会这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure></p>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p>
<p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 了解更多-&gt;</p>
<p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p>
<p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p>
<p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p>
<p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<p>使用 WATCH 实现 ZPOP<br>WATCH 可以用于创建 Redis 没有内置的原子操作。举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset 0 0</span><br><span class="line">MULTI</span><br><span class="line">ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p>
<p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是nil-reply回复即可。</p>
<h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p>
<p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>
<h3 id="Spring-Boot-例子"><a href="#Spring-Boot-例子" class="headerlink" title="Spring Boot 例子"></a>Spring Boot 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"默认测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer();</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; executeResult = stringRedisTemplate.execute((RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt; &#123;</span><br><span class="line">        <span class="comment">// 开启事物</span></span><br><span class="line">        connection.multi();</span><br><span class="line"></span><br><span class="line">        String testKey = String.format(<span class="string">"genericTestKey_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">        <span class="keyword">byte</span>[] defaultSerializeBytes = valueSerializer.serialize(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span> || defaultSerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"数据异常，无法操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置默认值：1</span></span><br><span class="line">            connection.set(testKeySerializeBytes, defaultSerializeBytes);</span><br><span class="line">            <span class="comment">// 给testKey incr 1</span></span><br><span class="line">            connection.incr(testKeySerializeBytes);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 删除testKey</span></span><br><span class="line">            connection.del(testKeySerializeBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行事物</span></span><br><span class="line">        <span class="keyword">return</span> connection.exec();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (executeResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"执行结果为空，无法操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    executeResult.forEach(o -&gt; logger.info(<span class="string">"executeResult:&#123;&#125;"</span>, o));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放弃事物</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"discard"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer();</span><br><span class="line"></span><br><span class="line">    stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        String testKey = String.format(<span class="string">"genericTestKey_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">        String defaultValue = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">        <span class="keyword">byte</span>[] defaultSerializeBytes = valueSerializer.serialize(defaultValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span> || defaultSerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"数据异常，无法操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置默认值：1</span></span><br><span class="line">            connection.set(testKeySerializeBytes, defaultSerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"testKey set value is :&#123;&#125;"</span>, defaultValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启事物</span></span><br><span class="line">            connection.multi();</span><br><span class="line">            logger.info(<span class="string">"multi "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给testKey incr 1</span></span><br><span class="line">            connection.incr(testKeySerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"inrc testKey "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 放弃事物</span></span><br><span class="line">            connection.discard();</span><br><span class="line">            logger.info(<span class="string">"discard"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新获得testKey的value</span></span><br><span class="line">            <span class="keyword">byte</span>[] nowTestKeyValueBytes = connection.get(testKeySerializeBytes);</span><br><span class="line">            <span class="keyword">if</span> (nowTestKeyValueBytes == <span class="keyword">null</span> || nowTestKeyValueBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"无法获取testKey的value"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String nowTestKeyValue = <span class="keyword">new</span> String(nowTestKeyValueBytes);</span><br><span class="line">            logger.info(<span class="string">"now testKey value is &#123;&#125;"</span>, nowTestKeyValue);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 删除testKey</span></span><br><span class="line">            connection.del(testKeySerializeBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事物 不回滚测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"noRollBackTest"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">noRollBackTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer();</span><br><span class="line"></span><br><span class="line">    stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        String testKey = String.format(<span class="string">"genericTestKey_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">        String defaultValue = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">        <span class="keyword">byte</span>[] defaultSerializeBytes = valueSerializer.serialize(defaultValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span> || defaultSerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"数据异常，无法操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置默认值：1</span></span><br><span class="line">            connection.set(testKeySerializeBytes, defaultSerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"testKey set value is :&#123;&#125;"</span>, defaultValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启事物</span></span><br><span class="line">            connection.multi();</span><br><span class="line">            logger.info(<span class="string">"multi "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给testKey incr 1</span></span><br><span class="line">            connection.incr(testKeySerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"inrc testKey "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 错误类型指令</span></span><br><span class="line">            connection.lPop(testKeySerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"lPop testKey"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给testKey incr 1</span></span><br><span class="line">            connection.incr(testKeySerializeBytes);</span><br><span class="line">            logger.info(<span class="string">"inrc testKey "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交之后虽然后异常，但是两次incr都成功执行了</span></span><br><span class="line">            RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123;</span><br><span class="line">                logger.info(<span class="string">"exec"</span>);</span><br><span class="line">                <span class="comment">// 提交</span></span><br><span class="line">                List&lt;Object&gt; execResult = connection.exec();</span><br><span class="line">                execResult.forEach(o -&gt; logger.info(<span class="string">"exec result:&#123;&#125;"</span>, o));</span><br><span class="line">            &#125;);</span><br><span class="line">            logger.error(<span class="string">"错误类型的命令异常"</span>,redisSystemException);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新获得testKey的value</span></span><br><span class="line">            <span class="keyword">byte</span>[] nowTestKeyValueBytes = connection.get(testKeySerializeBytes);</span><br><span class="line">            <span class="keyword">if</span> (nowTestKeyValueBytes == <span class="keyword">null</span> || nowTestKeyValueBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"无法获取testKey的value"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String nowTestKeyValue = <span class="keyword">new</span> String(nowTestKeyValueBytes);</span><br><span class="line">            logger.info(<span class="string">"now testKey value is &#123;&#125;"</span>, nowTestKeyValue);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 删除testKey</span></span><br><span class="line">            connection.del(testKeySerializeBytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/lru-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/lru-cache/" itemprop="url">将redis当做使用LRU算法的缓存来使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T15:17:50+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当Redis被当做缓存来使用，当你新增数据时，让它自动地回收旧数据是件很方便的事情。这个行为在开发者社区非常有名，因为它是memcached默认行为。</p>
<p>LRU是Redis唯一支持的回收方法。<br>本页面包括一些常规话题，Redis的maxmemory指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。</p>
<h3 id="Maxmemory配置指令"><a href="#Maxmemory配置指令" class="headerlink" title="Maxmemory配置指令"></a>Maxmemory配置指令</h3><p>maxmemory配置指令用于配置Redis存储数据时指定限制的内存大小。通过redis.conf可以设置该指令，或者之后使用CONFIG SET命令来进行运行时配置。</p>
<p>例如为了配置内存限制为100mb，以下的指令可以放在redis.conf文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure></p>
<p>设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。</p>
<p>当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。</p>
<h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><p>当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。</p>
<p>以下的策略是可用的:</p>
<ul>
<li>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</li>
<li>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li>svolatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<p>如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。</p>
<p>选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。</p>
<p>一般的经验规则:</p>
<ul>
<li>使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.</li>
<li>使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。</li>
<li>使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。</li>
</ul>
<p>allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。</p>
<p>为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。</p>
<h3 id="回收进程如何工作"><a href="#回收进程如何工作" class="headerlink" title="回收进程如何工作"></a>回收进程如何工作</h3><p>理解回收进程如何工作是非常重要的:</p>
<ul>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</li>
</ul>
<h3 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h3><p>Redis的LRU算法并非完整的实现。这意味着Redis并没办法选择最佳候选来进行回收，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。</p>
<p>不过从Redis 3.0算法已经改进为回收键的候选池子。这改善了算法的性能，使得更加近似真是的LRU算法的行为。</p>
<p>Redis LRU有个很重要的点，你通过调整每次回收时检查的采样数量，以实现调整算法的精度。这个参数可以通过以下的配置指令调整:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure></p>
<p>在模拟实验的过程中，我们发现如果使用幂定律的访问模式，则真实的LRU算法和近似的Redis算法几乎没有差别。</p>
<p>当然你可以提升采样大小到10，消耗更多的CPU时间以实现更真实的LRU算法，同时查看下是否让你的缓存命中率有差别。</p>
<p>通过CONFIG SET maxmemory-samples 命令在生产环境上设置不同的采样大小是非常简单的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/expire/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/expire/" itemprop="url">EXPIRE key seconds</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T17:54:39+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>设置key的过期时间，超过时间后，将会自动删除该key。在Redis的术语中一个key的相关超时是不确定的。</p>
<p>超时后只有对key执行DEL命令或者SET命令或者GETSET时才会清除。 这意味着，从概念上讲所有改变key的值的操作都会使他清除。 例如，INCR递增key的值，执行LPUSH操作，或者用HSET改变hash的field所有这些操作都会触发删除动作。</p>
<p>使用PERSIST命令可以清除超时，使其变成一个永久的key。</p>
<p>如果key被RENAME命令修改，相关的超时时间会转移到新key上面。</p>
<p>如果key被RENAME命令修改，比如原来就存在Key_A,然后调用RENAME Key_B Key_A命令，这时不管原来Key_A是永久的还是设置为超时的，都会由Key_B的有效期状态覆盖。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>支持版本: &gt;= 1.0.0</li>
<li>时间复杂度: O(1)</li>
<li>返回值： Integers<ul>
<li>1 如果成功设置过期时间。</li>
<li>0 如果key不存在或者不能设置过期时间。</li>
</ul>
</li>
</ul>
<h3 id="刷新过期时间"><a href="#刷新过期时间" class="headerlink" title="刷新过期时间"></a>刷新过期时间</h3><p>对已经有过期时间的key执行EXPIRE操作，将会更新它的过期时间。有很多应用有这种业务场景，例如记录会话的session。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIRE mykey 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; SET mykey <span class="string">"Hello World"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
<h3 id="案例-Navigation-session"><a href="#案例-Navigation-session" class="headerlink" title="案例: Navigation session"></a>案例: Navigation session</h3><p>想象一下，你有一个网络服务器，你对用户最近访问的N个网页感兴趣，每一个相邻的页面设置超时时间为60秒。在概念上你为这些网页添加Navigation session，如果你的用户，可能包含有趣的信息，他或她正在寻找什么样的产品，你可以推荐相关产品。</p>
<p>你可以使用下面的策略模型，使用这种模式：每次用户浏览网页调用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">RPUSH pagewviews.user:&lt;userid&gt; http://.....</span><br><span class="line">EXPIRE pagewviews.user:&lt;userid&gt; 60</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p>
<h3 id="附录-Redis-过期时间"><a href="#附录-Redis-过期时间" class="headerlink" title="附录: Redis 过期时间"></a>附录: Redis 过期时间</h3><h4 id="Keys的过期时间"><a href="#Keys的过期时间" class="headerlink" title="Keys的过期时间"></a>Keys的过期时间</h4><p>通常Redis keys创建时没有设置相关过期时间。他们会一直存在，除非使用显示的命令移除，例如，使用DEL命令。</p>
<p>EXPIRE一类命令能关联到一个有额外内存开销的key。当key执行过期操作时，Redis会确保按照规定时间删除他们。</p>
<p>key的过期时间和永久有效性可以通过EXPIRE和PERSIST命令（或者其他相关命令）来进行更新或者删除过期时间。</p>
<h4 id="过期精度"><a href="#过期精度" class="headerlink" title="过期精度"></a>过期精度</h4><p>在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。</p>
<p>从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。</p>
<h4 id="过期和持久"><a href="#过期和持久" class="headerlink" title="过期和持久"></a>过期和持久</h4><p>Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。</p>
<p>要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（所有的 keys装载时就会过期）。</p>
<p>即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。</p>
<h4 id="Redis如何淘汰过期的keys"><a href="#Redis如何淘汰过期的keys" class="headerlink" title="Redis如何淘汰过期的keys"></a>Redis如何淘汰过期的keys</h4><p>Redis keys过期有两种方式：被动和主动方式。</p>
<p>当一些客户端尝试访问它时，key会被发现并主动的过期。</p>
<p>当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。</p>
<p>具体就是Redis每秒10次做的事情：</p>
<ul>
<li>测试随机的20个keys进行相关过期检测。</li>
<li>删除所有已经过期的keys。</li>
<li>如果有多于25%的keys过期，重复步奏1.<br>这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。</li>
</ul>
<h4 id="在复制AOF文件时如何处理过期"><a href="#在复制AOF文件时如何处理过期" class="headerlink" title="在复制AOF文件时如何处理过期"></a>在复制AOF文件时如何处理过期</h4><p>为了获得正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有附加的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。</p>
<p>然而，当slaves连接到master时，不会独立过期keys（会等到master执行DEL命令），他们任然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/memory-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/10/memory-optimization/" itemprop="url">内存优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T17:02:39+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小的聚合类型数据的特殊编码处理"><a href="#小的聚合类型数据的特殊编码处理" class="headerlink" title="小的聚合类型数据的特殊编码处理"></a>小的聚合类型数据的特殊编码处理</h3><p>Redis2.2版本及以后，存储集合数据的时候会采用内存压缩技术，以使用更少的内存存储更多的数据。如Hashes,Lists,Sets和Sorted Sets，当这些集合中的所有数都小于一个给定的元素，并且集合中元素数量小于某个值时，存储的数据会被以一种非常节省内存的方式进行编码，使用这种编码理论上至少会节省10倍以上内存（平均节省5倍以上内存）。并且这种编码技术对用户和redis api透明。因为使用这种编码是用CPU换内存，所以我们提供了更改阈值的方法，只需在redis.conf里面进行修改即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-entries 64 (2.6以上使用hash-max-ziplist-entries)</span><br><span class="line">hash-max-zipmap-value 512  (2.6以上使用hash-max-ziplist-value)</span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure></p>
<p>（集合中）如果某个值超过了配置文件中设置的最大值，redis将自动把把它（集合）转换为正常的散列表。这种操作对于比较小的数值是非常快的，但是，如果你为了使用这种编码技术而把配置进行了更改，你最好做一下基准测试（和正常的不采用编码做一下对比）.</p>
<h3 id="使用32位的redis"><a href="#使用32位的redis" class="headerlink" title="使用32位的redis"></a>使用32位的redis</h3><p>使用32位的redis，对于每一个key,将使用更少的内存，因为32位程序，指针占用的字节数更少。但是32的redis整个实例使用的内存将被限制在4G以下。使用make 32bit命令编译生成32位的redis。RDB和AOF文件是不区分32位和64位的（包括字节顺序）,所以你可以使用64位的reidis恢复32位的RDB备份文件，相反亦然.</p>
<h3 id="位级别和字级别的操作"><a href="#位级别和字级别的操作" class="headerlink" title="位级别和字级别的操作"></a>位级别和字级别的操作</h3><p>Redis 2.2引入了位级别和字级别的操作: GETRANGE, SETRANGE, GETBIT 和 SETBIT.使用这些命令，你可以把redis的字符串当做一个随机读取的（字节）数组。例如你有一个应用，用来标志用户的ID是连续的整数，你可以使用一个位图标记用户的性别，使用1表示男性，0表示女性，或者其他的方式。这样的话，1亿个用户将仅使用12 M的内存。你可以使用同样的方法，使用 GETRANGE 和 SETRANGE 命令为每个用户存储一个字节的信息。这仅是一个例子，实际上你可以使用这些原始数据类型解决更多问题。</p>
<h3 id="尽可能使用散列表（hashes）"><a href="#尽可能使用散列表（hashes）" class="headerlink" title="尽可能使用散列表（hashes）"></a>尽可能使用散列表（hashes）</h3><p>小散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p>
<p>如果你想了解更多关于这方面的知识，请读下一段.</p>
<h3 id="使用散列结构高效存储抽象的键值对"><a href="#使用散列结构高效存储抽象的键值对" class="headerlink" title="使用散列结构高效存储抽象的键值对"></a>使用散列结构高效存储抽象的键值对</h3><p>我知道这部分的标题很吓人，但是我将详细解释这部分内容.</p>
<p>一般而言，把一个模型（model）表示为key-value的形式存储在redis中非常容易，当然value必须为字符串，这样存储不仅比一般的key value存储高效，并且比memcached存储还高效.</p>
<p>让我们做个对比：一些key存储了一个对象的多个字段要比一个散列表存储对象的多个字段占用更多的内存。这怎么可能？从原理上讲，为了保证查找一个数据总是在一个常量时间内（O(1)）,需要一个常量时间复杂度的数据结构，比如说散列表.</p>
<p>但是，通常情况下，散列表只包括极少的几个字段。当散列表非常小的时候，我们采用将数据encode为一个O(N)的数据结构，你可以认为这是一个带有长度属性的线性数组。只有当N是比较小的时候，才会采用这种encode，这样使用HGET和HSET命令的复杂度仍然是O(1)：当散列表包含的元素增长太多的时候，散列表将被转换为正常的散列表（极限值可以在redis.conf进行配置）.</p>
<p>无论是从时间复杂度还是从常量时间的角度来看，采用这种encode理论上都不会有多大性能提升，但是，一个线性数组通常会被CPU的缓存更好的命中（线性数组有更好的局部性）,从而提升了访问的速度.</p>
<p>既然散列表的字段及其对应的值并不是用redis objects表示，所以散列表的字段不能像普通的key一样设置过期时间。但是这毫不影响对散列表的使用，因为散列表本来就是这样设计的（我们相信简洁比多功能更重要，所以嵌入对象是不允许的，散列表字段设置单独的过期时间是不允许的）.</p>
<p>所以散列表能高效利用内存。这非常有用,当你使用一个散列表存储一个对象或者抽象其他一类相关的字段为一个模型时。但是，如果我们有一个普通的key value业务需求怎么办?</p>
<p>假如我们想使用redis存储许多小对象，这些对象可以使用json字符串表示，也可能是HTML片段和简单的key-&gt;boolean键值对。概况的说，一切皆字符串，都可以使用string:string的形式表示.</p>
<p>我们假设要缓存的对象使用数字后缀进行编码，如:</p>
<ul>
<li>object:102393</li>
<li>object:1234</li>
<li>object:5</li>
</ul>
<p>我们可以这样做。每次SET的时候，把key分为两部分，第一部分当做一个key，第二部当做散列表字段。比如“object:1234”,分成两部分:</p>
<ul>
<li>Key named object:12</li>
<li>Field named 34<br>我们使用除最后2个数字的部分作为key,最后2个数字做为散列表的字段。使用命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET object:12 34 somevalue</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如你所见，每个散列表将（理论上）包含100个字段，这是CPU资源和内存资源之间的一个折中.</p>
<p>另一个需要你关注的是在这种模式下，无论缓存多少对象，每个散列表都会分配100个字段。因为我们的对象总是以数字结尾，而不是一个随机的字符串。从某些方面来说，这是一种隐性的预分片。</p>
<p>对于小数字怎么处理？比如object:2,我们采用object:作为key,所有剩下的数字作为一个字段。所以object:2和object:10都会被存储到key为object:的散列表中，但是一个使用2作为字段，一个使用10作为字段。</p>
<p>这种方式将节省多少内存?</p>
<p>我使用了下面的Ruby程序进行了测试:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line">UseOptimization = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_get_key_field</span><span class="params">(key)</span></span></span><br><span class="line">    s = key.split(<span class="string">":"</span>)</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">1</span>].length &gt; <span class="number">2</span></span><br><span class="line">        &#123;<span class="symbol">:key</span> =&gt; s[<span class="number">0</span>]+<span class="string">":"</span>+s[<span class="number">1</span>][<span class="number">0</span>..-<span class="number">3</span>], <span class="symbol">:field</span> =&gt; s[<span class="number">1</span>][-<span class="number">2</span>..-<span class="number">1</span>]&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="symbol">:key</span> =&gt; s[<span class="number">0</span>]+<span class="string">":"</span>, <span class="symbol">:field</span> =&gt; s[<span class="number">1</span>]&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_set</span><span class="params">(r,key,value)</span></span></span><br><span class="line">    kf = hash_get_key_field(key)</span><br><span class="line">    r.hset(kf[<span class="symbol">:key</span>],kf[<span class="symbol">:field</span>],value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_get</span><span class="params">(r,key,value)</span></span></span><br><span class="line">    kf = hash_get_key_field(key)</span><br><span class="line">    r.hget(kf[<span class="symbol">:key</span>],kf[<span class="symbol">:field</span>],value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line">(<span class="number">0</span>..<span class="number">100000</span>).each&#123;<span class="params">|id|</span></span><br><span class="line">    key = <span class="string">"object:<span class="subst">#&#123;id&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> UseOptimization</span><br><span class="line">        hash_set(r,key,<span class="string">"val"</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r.set(key,<span class="string">"val"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在redis2.2的64位版本上测试结果:</p>
<ul>
<li>当开启优化时使用内存1.7M</li>
<li>当未开启优化时使用内存11M<br>从结果看出，这是一个数量级的优化，我认为这种优化使redis成为最出色的键值缓存。</li>
</ul>
<p>特别提示: 要使上面的程序较好的工作，别忘记设置你的redis:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-entries 256</span><br></pre></td></tr></table></figure></p>
<p>相应的最大键值长度设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash-max-zipmap-value 1024</span><br></pre></td></tr></table></figure></p>
<p>每次散列表的元素数量或者值超过了阈值，散列将被扩展为一张真正的散列表进行存储，此时节约存储的优势就没有了.</p>
<p>或许你想问，你为什么不自动将这些key进行转化以提高内存利用率？有两个原因：第一是因为我们更倾向于让这些权衡明确，而且必须在很多事情之间权衡：CPU，内存，最大元素大小限制。第二是顶级的键空间支持很多有趣的特性，比如过期，LRU算法，所以这种做法并不是一种通用的方法.</p>
<p>Redis的一贯风格是用户必须理解它是如何运作的，必须能够做出最好的选择和权衡，并且清楚它精确的运行方式.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/09/eval/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/eval/" itemprop="url">eval</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T14:40:42+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="EVAL-script-numkeys-key-key-…-arg-arg-…"><a href="#EVAL-script-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVAL script numkeys key [key …] arg [arg …]"></a>EVAL script numkeys key [key …] arg [arg …]</h3><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>EVAL 和 EVALSHA 命令是从 Redis 2.6.0 版本开始的，使用内置的 Lua 解释器，可以对 Lua 脚本进行求值。</p>
<p>EVAL的第一个参数是一段 Lua 5.1 脚本程序。 这段Lua脚本不需要（也不应该）定义函数。它运行在 Redis 服务器中。</p>
<p>EVAL的第二个参数是参数的个数，后面的参数（从第三个参数），表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p>
<p>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p>
<p>举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></figure></p>
<p>注：返回结果是Redis multi bulk replies的Lua数组，这是一个Redis的返回类型，您的客户端库可能会将他们转换成数组类型。</p>
<p>这是从一个Lua脚本中使用两个不同的Lua函数来调用Redis的命令的例子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.call()</span><br><span class="line">redis.<span class="built_in">pcall</span>()</span><br></pre></td></tr></table></figure></p>
<p>redis.call() 与 redis.pcall()很类似, 他们唯一的区别是当redis命令执行结果返回错误时， redis.call()将返回给调用者一个错误，而redis.pcall()会将捕获的错误以Lua表的形式返回</p>
<p>redis.call() 和 redis.pcall() 两个函数的参数可以是任意的 Redis 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set','foo','bar')"</span> 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set',KEYS[1],'bar')"</span> 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p>
<p>因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。 除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。 (对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的， 从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p>
<p>Lua 脚本能返回一个值，这个值能按照一组转换规则从Lua转换成redis的返回类型。</p>
<h3 id="Lua-数据类型和-Redis-数据类型之间转换"><a href="#Lua-数据类型和-Redis-数据类型之间转换" class="headerlink" title="Lua 数据类型和 Redis 数据类型之间转换"></a>Lua 数据类型和 Redis 数据类型之间转换</h3><p>当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。 同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。</p>
<p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p>
<p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p>
<h4 id="Redis-到-Lua-的转换表。"><a href="#Redis-到-Lua-的转换表。" class="headerlink" title="Redis 到 Lua 的转换表。"></a>Redis 到 Lua 的转换表。</h4><ul>
<li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li>
<li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li>
<li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li>
<li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 ok 域包含了状态信息</li>
<li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 err 域包含了错误信息</li>
<li>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 false</li>
</ul>
<h4 id="Lua-到-Redis-的转换表。"><a href="#Lua-到-Redis-的转换表。" class="headerlink" title="Lua 到 Redis 的转换表。"></a>Lua 到 Redis 的转换表。</h4><ul>
<li>Lua number -&gt; Redis integer reply (the number is converted into an integer) / Lua 数字转换成 Redis 整数</li>
<li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li>
<li>Lua table (array) -&gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any) / Lua 表(数组)转换成 Redis 多条 bulk 回复</li>
<li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 ok 域的 Lua 表，转换成 Redis 状态回复</li>
<li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 err 域的 Lua 表，转换成 Redis 错误回复</li>
<li>Lua boolean false -&gt; Redis Nil bulk reply. / Lua 的布尔值 false 转换成 Redis 的 Nil bulk 回复<br>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</li>
<li>Lua boolean true -&gt; Redis integer reply with value of 1. / Lua 布尔值 true 转换成 Redis 整数回复中的 1</li>
</ul>
<p>还有下面两点需要重点注意：</p>
<ul>
<li>lua中整数和浮点数之间没有什么区别。因此，我们始终Lua的数字转换成整数的回复，这样将舍去小数部分。如果你想从Lua返回一个浮点数，你应该将它作为一个字符串（见比如ZSCORE命令）。</li>
<li>There is no simple way to have nils inside Lua arrays, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</li>
</ul>
<p>以下是几个类型转换的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return 10"</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"</span> 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 3</span><br><span class="line">   2) <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure></p>
<p>最后一个例子展示如果是Lua直接命令调用它是如何可以从redis.call()或redis.pcall()接收到准确的返回值。</p>
<p>下面的例子我们可以看到浮点数和nil将怎么样处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;1,2,3.3333,'foo',nil,'bar'&#125;"</span> 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></p>
<p>正如你看到的 3.333 被转换成了3，并且 nil后面的字符串bar没有被返回回来。</p>
<h3 id="返回redis类型的辅助函数"><a href="#返回redis类型的辅助函数" class="headerlink" title="返回redis类型的辅助函数"></a>返回redis类型的辅助函数</h3><p>有两个辅助函数从Lua返回Redis的类型。</p>
<ul>
<li>redis.error_reply(error_string) returns an error reply. This function simply returns the single field table with the err field set to the specified string for you.</li>
<li>redis.status_reply(status_string) returns a status reply. This function simply returns the single field table with the ok field set to the specified string for you.</li>
</ul>
<p>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;err=<span class="string">"My Error"</span>&#125;</span><br><span class="line"><span class="keyword">return</span> redis.error_reply(<span class="string">"My Error"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="脚本的原子性"><a href="#脚本的原子性" class="headerlink" title="脚本的原子性"></a>脚本的原子性</h3><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI / EXEC 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。 另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难， 因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心， 因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。</p>
<p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; del foo</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lpush foo a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_6b1bf486c81ceb7edf3c093f4c48582e38c0e791): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p>
<p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL <span class="string">"return redis.pcall('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p>
<h3 id="带宽和-EVALSHA"><a href="#带宽和-EVALSHA" class="headerlink" title="带宽和 EVALSHA"></a>带宽和 EVALSHA</h3><p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p>
<p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p>
<p>EVALSHA 命令的表现如下：</p>
<p>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本 如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA 以下是示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/<span class="built_in">eval</span>).</span><br></pre></td></tr></table></figure></p>
<p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。</p>
<p>这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗</p>
<h3 id="脚本缓存"><a href="#脚本缓存" class="headerlink" title="脚本缓存"></a>脚本缓存</h3><p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p>
<p>刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p>
<p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p>
<p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p>
<h3 id="SCRIPT-命令"><a href="#SCRIPT-命令" class="headerlink" title="SCRIPT 命令"></a>SCRIPT 命令</h3><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p>
<ul>
<li>SCRIPT FLUSH ：清除所有脚本缓存 </li>
<li>SCRIPT EXISTS ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存 </li>
<li>SCRIPT LOAD ：将一个脚本装入脚本缓存，但并不立即运行它 </li>
<li>SCRIPT KILL ：杀死当前正在运行的脚本</li>
</ul>
<h3 id="纯函数脚本"><a href="#纯函数脚本" class="headerlink" title="纯函数脚本"></a>纯函数脚本</h3><p>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</p>
<p>也就是说，脚本应该具有以下属性：</p>
<ul>
<li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li>
</ul>
<p>使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p>
<p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p>
<ul>
<li>Lua 没有访问系统时间或者其他内部状态的命令</li>
<li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 RANDOMKEY 、 SRANDMEMBER 或 TIME 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 TIME 命令就是这方面的一个很好的例子。</li>
<li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(lexicographical sorting)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 SMEMBERS ，返回的元素是无序的，但是，假如在脚本中执行 redis.call(“smembers”, KEYS[1]) ，那么返回的总是排过序的元素。</li>
<li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 math.randomseed ，那么 math.random 产生的随机数序列总是相同的。<br>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</li>
</ul>
<p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="string">    local i = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">    local res</span></span><br><span class="line"><span class="string">    while (i &gt; 0) do</span></span><br><span class="line"><span class="string">        res = redis.call('lpush',KEYS[1],math.random())</span></span><br><span class="line"><span class="string">        i = i-1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(<span class="symbol">:mylist</span>)</span><br><span class="line">puts r.eval(RandomPushScript,[<span class="symbol">:mylist</span>],[<span class="number">10</span>,rand(<span class="number">2</span>**<span class="number">32</span>)])</span><br></pre></td></tr></table></figure></p>
<p>这个程序每次运行都会生成带有以下元素的列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"0.74509509873814"</span></span><br><span class="line">2) <span class="string">"0.87390407681181"</span></span><br><span class="line">3) <span class="string">"0.36876626981831"</span></span><br><span class="line">4) <span class="string">"0.6921941534114"</span></span><br><span class="line">5) <span class="string">"0.7857992587545"</span></span><br><span class="line">6) <span class="string">"0.57730350670279"</span></span><br><span class="line">7) <span class="string">"0.87046522734243"</span></span><br><span class="line">8) <span class="string">"0.09637165539729"</span></span><br><span class="line">9) <span class="string">"0.74990198051087"</span></span><br><span class="line">10) <span class="string">"0.17082803611217"</span></span><br></pre></td></tr></table></figure></p>
<p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？<br>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p>
<p>以下是修改后的脚本：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="string">    local i = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">    local res</span></span><br><span class="line"><span class="string">    math.randomseed(tonumber(ARGV[2]))</span></span><br><span class="line"><span class="string">    while (i &gt; 0) do</span></span><br><span class="line"><span class="string">        res = redis.call('lpush',KEYS[1],math.random())</span></span><br><span class="line"><span class="string">        i = i-1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(<span class="symbol">:mylist</span>)</span><br><span class="line">puts r.eval(RandomPushScript,<span class="number">1</span>,<span class="symbol">:mylist</span>,<span class="number">10</span>,rand(<span class="number">2</span>**<span class="number">32</span>))</span><br></pre></td></tr></table></figure></p>
<p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p>
<p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p>
<p>注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p>
<h3 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h3><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p>
<p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; eval &apos;a=10&apos; 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable &apos;a&apos;</span><br></pre></td></tr></table></figure></p>
<p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p>
<p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p>
<p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。</p>
<h3 id="使用选择内部脚本"><a href="#使用选择内部脚本" class="headerlink" title="使用选择内部脚本"></a>使用选择内部脚本</h3><p>在正常的客户端连接里面可以调用SELECT选择内部的Lua脚本，但是Redis 2.8.11和Redis 2.8.12在行为上有一个微妙的变化。在2.8.12之前，会将脚本传送到调用脚本的当前数据库。从2.8.12开始Lua脚本只影响脚本本身的执行，但不修改当前客户端调用脚本时选定的数据库。</p>
<p>从补丁级发布的语义变化是必要的，因为旧的行为与Redis复制层固有的不相容是错误的原因。</p>
<h3 id="可用库"><a href="#可用库" class="headerlink" title="可用库"></a>可用库</h3><p>Redis Lua解释器可用加载以下Lua库：</p>
<ul>
<li>base lib.</li>
<li>table lib.</li>
<li>string lib.</li>
<li>math lib.</li>
<li>debug lib.</li>
<li>struct lib.</li>
<li>cjson lib.</li>
<li>cmsgpack lib.</li>
<li>bitop lib.</li>
<li>redis.sha1hex function.</li>
</ul>
<p>每一个Redis实例都拥有以上的所有类库，以确保您使用脚本的环境都是一样的。</p>
<p>struct, CJSON 和 cmsgpack 都是外部库, 所有其他库都是标准。 Lua库。</p>
<p>struct 库<br>struct 是一个Lua装箱/拆箱的库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Valid formats:</span><br><span class="line">&gt; - big endian</span><br><span class="line">&lt; - little endian</span><br><span class="line">![num] - alignment</span><br><span class="line">x - pading</span><br><span class="line">b/B - signed/unsigned byte</span><br><span class="line">h/H - signed/unsigned short</span><br><span class="line">l/L - signed/unsigned long</span><br><span class="line">T   - size_t</span><br><span class="line">i/In - signed/unsigned integer with size `n&apos; (default is size of int)</span><br><span class="line">cn - sequence of `n&apos; chars (from/to a string); when packing, n==0 means</span><br><span class="line">     the whole string; when unpacking, n==0 means use the previous</span><br><span class="line">     read number as the string length</span><br><span class="line">s - zero-terminated string</span><br><span class="line">f - float</span><br><span class="line">d - double</span><br><span class="line">&apos; &apos; - ignored</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return struct.pack("HH", 1, 2)'</span> 0</span><br><span class="line"><span class="string">"\x01\x00\x02\x00"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return &#123;struct.unpack("HH", ARGV[1])&#125;'</span> 0 <span class="string">"\x01\x00\x02\x00"</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return struct.size("HH")'</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure></p>
<h3 id="CJSON-库"><a href="#CJSON-库" class="headerlink" title="CJSON 库"></a>CJSON 库</h3><p>CJSON 库为Lua提供极快的JSON处理</p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return cjson.encode(&#123;["foo"]= "bar"&#125;)'</span> 0</span><br><span class="line"><span class="string">"&#123;\"foo\":\"bar\"&#125;"</span></span><br><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return cjson.decode(ARGV[1])["foo"]'</span> 0 <span class="string">"&#123;\"foo\":\"bar\"&#125;"</span></span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="cmsgpack-库"><a href="#cmsgpack-库" class="headerlink" title="cmsgpack 库"></a>cmsgpack 库</h3><p>cmsgpack 库为Lua提供了简单、快速的MessagePack操纵</p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return cmsgpack.pack(&#123;"foo", "bar", "baz"&#125;)'</span> 0</span><br><span class="line"><span class="string">"\x93\xa3foo\xa3bar\xa3baz"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return cmsgpack.unpack(ARGV[1])'</span> 0 <span class="string">"\x93\xa3foo\xa3bar\xa3baz"</span></span><br><span class="line">1) <span class="string">"foo"</span></span><br><span class="line">2) <span class="string">"bar"</span></span><br><span class="line">3) <span class="string">"baz"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="bitop-库"><a href="#bitop-库" class="headerlink" title="bitop 库"></a>bitop 库</h3><p>bitop库为Lua的位运算模块增加了按位操作数。 它是Redis 2.8.18开始加入的。</p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return bit.tobit(1)'</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return bit.bor(1,2,4,8,16,32,64,128)'</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 255</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return bit.tohex(422342)'</span> 0</span><br><span class="line"><span class="string">"000671c6"</span></span><br></pre></td></tr></table></figure></p>
<p>它支持几个其他功能： </p>
<ul>
<li>bit.tobit</li>
<li>bit.tohex</li>
<li>bit.bnot</li>
<li>bit.band</li>
<li>bit.bor</li>
<li>bit.bxor</li>
<li>bit.lshift</li>
<li>bit.rshift</li>
<li>bit.arshift</li>
<li>bit.rol</li>
<li>bit.ror</li>
<li>bit.bswap</li>
</ul>
<h3 id="redis-sha1hex"><a href="#redis-sha1hex" class="headerlink" title="redis.sha1hex"></a>redis.sha1hex</h3><p>对字符串执行SHA1算法</p>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'return redis.sha1hex(ARGV[1])'</span> 0 <span class="string">"foo"</span></span><br><span class="line"><span class="string">"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用脚本记录-Redis-日志"><a href="#使用脚本记录-Redis-日志" class="headerlink" title="使用脚本记录 Redis 日志"></a>使用脚本记录 Redis 日志</h3><p>在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">log</span>(loglevel,message)</span><br></pre></td></tr></table></figure></p>
<p>其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值：</p>
<ul>
<li>redis.LOG_DEBUG</li>
<li>redis.LOG_VERBOSE</li>
<li>redis.LOG_NOTICE</li>
<li>redis.LOG_WARNING</li>
</ul>
<p>上面的这些等级(level)和标准 Redis 日志的等级相对应。</p>
<p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p>
<p>以下是一个日志示例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.<span class="built_in">log</span>(redis.LOG_WARNING, <span class="string">"Something is wrong with this script."</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行上面的函数会产生这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32343] 22 Mar 15:21:39 # Something is wrong with this script.</span><br></pre></td></tr></table></figure></p>
<h3 id="沙箱-sandbox-和最大执行时间"><a href="#沙箱-sandbox-和最大执行时间" class="headerlink" title="沙箱(sandbox)和最大执行时间"></a>沙箱(sandbox)和最大执行时间</h3><p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p>
<p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p>
<p>最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET 和 CONFIG SET 命令来修改它。</p>
<p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p>
<p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p>
<ul>
<li>Redis 记录一个脚本正在超时运行</li>
<li>Redis 开始重新接受其他客户端的命令请求，但是只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 BUSY 错误。</li>
<li>可以使用 SCRIPT KILL 命令将一个仅执行只读命令的脚本杀死，因为- - 只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性<br>如果脚本已经执行过写命令，那么唯一允许执行的操作就是 SHUTDOWN NOSAVE ，它通过停止服务器来阻止当前数据集写入磁盘</li>
</ul>
<h3 id="流水线-pipeline-上下文-context-中的-EVALSHA"><a href="#流水线-pipeline-上下文-context-中的-EVALSHA" class="headerlink" title="流水线(pipeline)上下文(context)中的 EVALSHA"></a>流水线(pipeline)上下文(context)中的 EVALSHA</h3><p>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</p>
<p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p>
<p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p>
<ul>
<li>总是在流水线中使用 EVAL 命令</li>
<li>检查流水线中要用到的所有命令，找到其中的 EVAL 命令，并使用 SCRIPT EXISTS 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 EVAL 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 SCRIPT LOAD 命令加上去。</li>
</ul>
<h3 id="Spring-Boot-例子"><a href="#Spring-Boot-例子" class="headerlink" title="Spring Boot 例子"></a>Spring Boot 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"脚本参数测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paramsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List resultList = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;List&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回脚本的sha1加密值</span></span><br><span class="line"><span class="comment">         * 避免重复传递脚本带来的性能损耗</span></span><br><span class="line"><span class="comment">         * Redis提供了一组命令：</span></span><br><span class="line"><span class="comment">         * SCRIPT LOAD 脚本 把脚本加载进Redis缓存中</span></span><br><span class="line"><span class="comment">         * SCRIPT EXIST sha1值 判断sha1是否存在于Redis缓存</span></span><br><span class="line"><span class="comment">         * EVALSHA sha1值 参数 通过sha1的方式云效指定的脚本</span></span><br><span class="line"><span class="comment">         * 本方法的作用主要是提供Redis脚本sha1后的值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 脚本sha1后的加密值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 脚本发返回值的Class实例</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 返回值的Class实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Class&lt;List&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> List.class;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 脚本</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 脚本</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, Arrays.asList(<span class="string">"key1"</span>, <span class="string">"key2"</span>), <span class="string">"arg1"</span>, <span class="string">"arg2"</span>);</span><br><span class="line"></span><br><span class="line">    Assertions.assertNotNull(resultList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object result : resultList) &#123;</span><br><span class="line">        logger.info(<span class="string">"paramsTest,result:&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"返回数字测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">returnNumberTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个地方有个坑，就是返回的数字没法包含小数</span></span><br><span class="line">    <span class="comment">// 如果要返回小数则需要在脚本里面转为string类型</span></span><br><span class="line">    <span class="comment">// 然后返回值用String接收</span></span><br><span class="line">    Number result = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;Number&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Class&lt;Number&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Number.class;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return 234.567"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, Collections.singletonList(<span class="string">"key1"</span>));</span><br><span class="line">    Assertions.assertNotNull(result);</span><br><span class="line">    logger.info(<span class="string">"result:&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"返回布尔值"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">returnBooleanTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Boolean result = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Class&lt;Boolean&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.class;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return true"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, Collections.singletonList(<span class="string">"key1"</span>));</span><br><span class="line">    logger.info(<span class="string">"result:&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"错误处理-redis.call"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorTestByCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虽然call 和 pcall测试用例都抛出了异常</span></span><br><span class="line">    <span class="comment">// 但是从运行结果上来看，可以发现</span></span><br><span class="line">    <span class="comment">// pcall 和call 最大的区别就是call会中断脚本的执行</span></span><br><span class="line">    <span class="comment">// 而pcall 只会在方法的返回值上返回一个错误信息</span></span><br><span class="line">    ListOperations&lt;String, String&gt; stringStringListOperations = stringRedisTemplate.opsForList();</span><br><span class="line">    String testKey = String.format(<span class="string">"errorTestByCall_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stringStringListOperations.leftPush(testKey, UUID.randomUUID().toString());</span><br><span class="line">        RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123;</span><br><span class="line">            Object result = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;Object&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Object.class;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"redis.call('get',KEYS[1])\n"</span> +</span><br><span class="line">                            <span class="string">"redis.call('lpush ',KEYS[1],KEYS[1])"</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, Collections.singletonList(testKey));</span><br><span class="line">            logger.info(<span class="string">"result:&#123;&#125;"</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.error(<span class="string">"error"</span>, redisSystemException);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String leftPop = stringStringListOperations.leftPop(testKey);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(leftPop)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"leftPop:&#123;&#125;"</span>, leftPop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"错误处理-redis.pcall"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errorTestByPCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虽然call 和 pcall测试用例都抛出了异常</span></span><br><span class="line">    <span class="comment">// 但是从运行结果上来看，可以发现</span></span><br><span class="line">    <span class="comment">// pcall 和call 最大的区别就是call会中断脚本的执行</span></span><br><span class="line">    <span class="comment">// 而pcall 只会在方法的返回值上返回一个错误信息</span></span><br><span class="line">    ListOperations&lt;String, String&gt; stringStringListOperations = stringRedisTemplate.opsForList();</span><br><span class="line">    String testKey = String.format(<span class="string">"errorTestByPCall_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stringStringListOperations.leftPush(testKey, UUID.randomUUID().toString());</span><br><span class="line">        RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123;</span><br><span class="line">            Object result = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Class&lt;Object&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Object.class;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"local error = redis.pcall('get',KEYS[1])\n"</span> +</span><br><span class="line">                            <span class="string">"redis.pcall('lpush',KEYS[1],KEYS[1])\n"</span> +</span><br><span class="line">                            <span class="string">"return error"</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, Collections.singletonList(testKey));</span><br><span class="line">            logger.info(<span class="string">"result:&#123;&#125;"</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.error(<span class="string">"error"</span>, redisSystemException);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String leftPop = stringStringListOperations.leftPop(testKey);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(leftPop)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">"leftPop:&#123;&#125;"</span>, leftPop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"返回复杂的数据"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">returnManyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List resultList = stringRedisTemplate.execute(<span class="keyword">new</span> RedisScript&lt;List&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSha1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DigestUtils.sha1DigestAsHex(getScriptAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Class&lt;List&gt; <span class="title">getResultType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> List.class;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getScriptAsString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, Collections.singletonList(<span class="string">"testKey"</span>));</span><br><span class="line">    Assertions.assertNotNull(resultList);</span><br><span class="line">    <span class="keyword">for</span> (Object obj : resultList) &#123;</span><br><span class="line">        logger.info(<span class="string">"obj[&#123;&#125;]:&#123;&#125;"</span>, obj.getClass().getSimpleName(), obj);</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            List childObjList = (List) obj;</span><br><span class="line">            <span class="keyword">for</span> (Object childObj : childObjList) &#123;</span><br><span class="line">                logger.info(<span class="string">"childObj[&#123;&#125;]:&#123;&#125;"</span>, childObj.getClass().getSimpleName(), childObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/09/pipelining/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/pipelining/" itemprop="url">管道（Pipelining）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T13:28:57+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="请求-响应协议和RTT"><a href="#请求-响应协议和RTT" class="headerlink" title="请求/响应协议和RTT"></a>请求/响应协议和RTT</h3><p>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。</p>
<p>这意味着通常情况下一个请求会遵循以下步骤：</p>
<p>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。<br>服务端处理命令，并将结果返回给客户端。<br>因此，例如下面是4个命令序列执行情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Client: INCR X</span><br><span class="line">Server: 1</span><br><span class="line">Client: INCR X</span><br><span class="line">Server: 2</span><br><span class="line">Client: INCR X</span><br><span class="line">Server: 3</span><br><span class="line">Client: INCR X</span><br><span class="line">Server: 4</span><br></pre></td></tr></table></figure></p>
<p>客户端和服务器通过网络进行连接。这个连接可以很快（loopback接口）或很慢（建立了一个多次跳转的网络连接）。无论网络延如何延时，数据包总是能从客户端到达服务器，并从服务器返回数据回复客户端。</p>
<p>这个时间被称之为 RTT (Round Trip Time - 往返时间). 当客户端需要在一个批处理中执行多次请求时很容易看到这是如何影响性能的（例如添加许多元素到同一个list，或者用很多Keys填充数据库）。例如，如果RTT时间是250毫秒（在一个很慢的连接下），即使服务器每秒能处理100k的请求数，我们每秒最多也只能处理4个请求。</p>
<p>如果采用loopback接口，RTT就短得多（比如我的主机ping 127.0.0.1只需要44毫秒），但它任然是一笔很多的开销在一次批量写入操作中。</p>
<p>幸运的是有一种方法可以改善这种情况。</p>
<h3 id="Redis-管道（Pipelining）"><a href="#Redis-管道（Pipelining）" class="headerlink" title="Redis 管道（Pipelining）"></a>Redis 管道（Pipelining）</h3><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>Redis很早就支持管道（pipelining）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作Redis。下面是一个使用的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ (<span class="built_in">printf</span> <span class="string">"PING\r\nPING\r\nPING\r\n"</span>; sleep 1) | nc localhost 6379</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br><span class="line">+PONG</span><br></pre></td></tr></table></figure></p>
<p>这一次我们没有为每个命令都花费了RTT开销，而是只用了一个命令的开销时间。</p>
<p>非常明确的，用管道顺序操作的第一个例子如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Client: INCR X</span><br><span class="line">Client: INCR X</span><br><span class="line">Client: INCR X</span><br><span class="line">Client: INCR X</span><br><span class="line">Server: 1</span><br><span class="line">Server: 2</span><br><span class="line">Server: 3</span><br><span class="line">Server: 4</span><br></pre></td></tr></table></figure></p>
<h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><p>使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。</p>
<h3 id="这不仅仅是RTT的问题"><a href="#这不仅仅是RTT的问题" class="headerlink" title="这不仅仅是RTT的问题"></a>这不仅仅是RTT的问题</h3><p>不仅仅是为了减少往返时间所带来的延迟成本，它实际上可以提高您在给定的Redis服务器上每秒执行的总操作量。<br>这是事实的结果，即在不使用管道的情况下，从访问数据结构和生成答复的角度来看，每个命令的消耗都非常低，<br>但从调用的Socket I/O角度来看. 这涉及read()和write()的系统调用，意味着需要从用户空间到内核的空间不断的切换，而上下文切换会有巨大的消耗。</p>
<p>当使用管道时，多个命令通常只用一次read()来从Socket IO读取出来，而多次响应则通过一次write()系统调用来传递。<br>因此，Redis每秒执行查询速率会随着随着较长的管道提高，并最终达到未使用管道情况的10倍</p>
<h3 id="Ruby例子"><a href="#Ruby例子" class="headerlink" title="Ruby例子"></a>Ruby例子</h3><p>在以下基准测试中，我们将使用支持流水线的Redis Ruby客户端来测试由于流水线而导致的速度提升：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bench</span><span class="params">(descr)</span></span></span><br><span class="line">    start = Time.now</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    puts <span class="string">"<span class="subst">#&#123;descr&#125;</span> <span class="subst">#&#123;Time.now-start&#125;</span> seconds"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">without_pipelining</span></span></span><br><span class="line">    r = Redis.new</span><br><span class="line">    <span class="number">10000</span>.times &#123;</span><br><span class="line">        r.ping</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_pipelining</span></span></span><br><span class="line">    r = Redis.new</span><br><span class="line">    r.pipelined &#123;</span><br><span class="line">        <span class="number">10000</span>.times &#123;</span><br><span class="line">            r.ping</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">bench(<span class="string">"without pipelining"</span>) &#123;</span><br><span class="line">    without_pipelining</span><br><span class="line">&#125;</span><br><span class="line">bench(<span class="string">"with pipelining"</span>) &#123;</span><br><span class="line">    with_pipelining</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述简单脚本将在我的Mac OS X系统中提供以下图形，通过环回接口运行，其中流水线将提供最小的改进，因为RTT已经非常低：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">without pipelining 1.185238 seconds</span><br><span class="line">with pipelining 0.250783 seconds</span><br></pre></td></tr></table></figure></p>
<p>正如您所看到的，使用流水线，我们将传输改进了五倍。</p>
<h3 id="Spring-Boot-例子"><a href="#Spring-Boot-例子" class="headerlink" title="Spring Boot 例子"></a>Spring Boot 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"批量GET测试"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">batchGetTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试的key</span></span><br><span class="line">    String testKey = String.format(<span class="string">"keyNotExistTest_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">    RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"编码testKey失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// testKey对应的原始值</span></span><br><span class="line">        String originalValue = <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey is &#123;&#125;"</span>, testKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置testKey一个值，因此testKey会存在与redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(testKey, originalValue);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey set value is &#123;&#125;,so the key is exist in redis"</span>, originalValue);</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; resultList = stringRedisTemplate.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                connection.get(testKeySerializeBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在Pipeline情况下只能返回NULL</span></span><br><span class="line">            <span class="comment">// 毕竟是有点异步的意思，不能立马获得命令的结果的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        resultList.forEach(o -&gt; logger.info(<span class="string">"pipeline result is &#123;&#125;"</span>, o));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后删除这个key，避免产生大量无用数据</span></span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"批量SET"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">batchSetTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; testKeyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Object&gt; resultList = stringRedisTemplate.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 测试的key</span></span><br><span class="line">                String testKey = String.format(<span class="string">"batchSetTest_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">                testKeyList.add(testKey);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// testKey对应的原始值</span></span><br><span class="line">                String value = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">                logger.info(<span class="string">"testKey is &#123;&#125;"</span>, testKey);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">                <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"编码testKey失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">byte</span>[] valueSerializeBytes = valueSerializer.serialize(value);</span><br><span class="line">                <span class="keyword">if</span> (valueSerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"编码testKey失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connection.set(testKeySerializeBytes, valueSerializeBytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在Pipeline情况下只能返回NULL</span></span><br><span class="line">            <span class="comment">// 毕竟是有点异步的意思，不能立马获得命令的结果的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        resultList.forEach(o -&gt; logger.info(<span class="string">"pipeline result is &#123;&#125;"</span>, o));</span><br><span class="line">        testKeyList.forEach(testKey -&gt; &#123;</span><br><span class="line">            String value = stringRedisTemplate.opsForValue().get(testKey);</span><br><span class="line">            logger.info(<span class="string">"after pipeline get testKey:&#123;&#125;,value is &#123;&#125;"</span>, testKey, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(testKeyList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流水线VS脚本"><a href="#流水线VS脚本" class="headerlink" title="流水线VS脚本"></a>流水线VS脚本</h3><p>使用Redis脚本（Redis版本2.6或更高版本中可用），可以使用执行服务器端所需大量工作的脚本更高效地处理大量流水线用例。<br>脚本的一大优点是它能够以最小的延迟读取和写入数据，使得读取，计算，写入等操作非常快速（在这种情况下流水线操作无法提供帮助，因为客户端需要先读取命令的回复它可以调用写命令）。</p>
<p>简单理解，就是单一的批量操作，适合用用管道方式<br>如果遇到下一个命令参数是上一个命令的结果构成，那适合脚本方式</p>
<p>有时，应用程序可能还想在管道中发送EVAL或EVALSHA命令。这是完全可能的，并且Redis通过SCRIPT LOAD命令明确支持它（它保证可以在没有失败风险的情况下调用EVALSHA）。</p>
<h3 id="附录：为什么即使在本地回环接口上，一个繁忙的循环也很慢？"><a href="#附录：为什么即使在本地回环接口上，一个繁忙的循环也很慢？" class="headerlink" title="附录：为什么即使在本地回环接口上，一个繁忙的循环也很慢？"></a>附录：为什么即使在本地回环接口上，一个繁忙的循环也很慢？</h3><p>即使在本页面介绍的所有背景下，您仍然可能仍然想知道为什么如下所示的Redis基准测试（在伪代码中），即使在回环接口中执行时，服务器和客户端在同一物理机器上运行时，也很慢：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOR-ONE-SECOND:</span><br><span class="line">    Redis.SET(&quot;foo&quot;,&quot;bar&quot;)</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
<p>毕竟，如果Redis进程和基准测试都在同一个机器上运行，那么这不仅仅是通过内存从一个地方复制到另一个地方，而没有任何实际的延迟和实际网络？</p>
<p>原因是系统中的进程并不总是在运行，实际上它是让进程运行的内核调度器，所以会发生什么，例如，允许基准运行，从Redis服务器读取回复（相关到执行的最后一个命令），并写入一个新的命令。该命令现在位于回环接口缓冲区中，但为了被服务器读取，内核应该安排服务器进程（当前在系统调用中阻塞）运行，等等。因此，实际上，由于内核调度程序的工作原理，回送接口仍然涉及网络延迟。</p>
<p>基本上，一个繁忙的循环基准测试是在网络服务器中测量性能时可以完成的最难的事情。明智的做法是以这种方式避免基准测试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/DECR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/DECR/" itemprop="url">DECR</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T17:39:20+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h3><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>支持版本: &gt;= 1.0.0</li>
<li>时间复杂度: O(1)</li>
<li>返回值: Integers,减小之后的value</li>
</ul>
<hr>
<h3 id="redis-cli-例子"><a href="#redis-cli-例子" class="headerlink" title="redis-cli 例子"></a>redis-cli 例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"10"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECR mykey</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">redis&gt; SET mykey <span class="string">"234293482390480948029348230948"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; DECR mykey</span><br><span class="line">ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">redis&gt; DEL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Boot例子"><a href="#Spring-Boot例子" class="headerlink" title="Spring Boot例子"></a>Spring Boot例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"testKey不存在的情况"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testKeyNotExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试的key</span></span><br><span class="line">    String testKey = String.format(<span class="string">"keyNotExistTest_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"序列化testKey失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey is &#123;&#125;,the testKey is a random key ,so it not exist in redis"</span>, testKey);</span><br><span class="line"></span><br><span class="line">        Long decreaseReturn = stringRedisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">doInRedis</span><span class="params">(@Nullable RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"无法连接redis"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> connection.decr(testKeySerializeBytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey decr is ok and result is &#123;&#125;"</span>, decreaseReturn);</span><br><span class="line"></span><br><span class="line">        String value = stringRedisTemplate.opsForValue().get(testKey);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"after decr,value is:&#123;&#125;"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后删除这个key，避免产生大量无用数据</span></span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"testKey存在的情况"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testKeyExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试Key</span></span><br><span class="line">    String testKey = String.format(<span class="string">"keyExistTest_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"序列化testKey失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// testKey对应的原始值</span></span><br><span class="line">        String originalValue = <span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey is &#123;&#125;"</span>, testKey);</span><br><span class="line"></span><br><span class="line">        ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置testKey一个值，因此testKey会存在与redis</span></span><br><span class="line">        stringStringValueOperations.set(testKey, originalValue);</span><br><span class="line">        logger.info(<span class="string">"testKey set value is &#123;&#125;,so the key is exist in redis"</span>, originalValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在testKey存在的情况下append</span></span><br><span class="line">        Long decreaseValueReturn = stringRedisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">doInRedis</span><span class="params">(@Nullable RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"链接Redis失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> connection.decr(testKeySerializeBytes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.info(<span class="string">"testKey decr ok and result is &#123;&#125;"</span>, decreaseValueReturn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新获取testKey的值</span></span><br><span class="line">        String newValue = stringStringValueOperations.get(testKey);</span><br><span class="line">        logger.info(<span class="string">"after decr testKey`s value is &#123;&#125;"</span>, newValue);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后删除这个key，避免产生大量无用数据</span></span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"value不是数字情况下"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">valueNotNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试Key</span></span><br><span class="line">    String testKey = String.format(<span class="string">"valueNotNumber_%s"</span>, UUID.randomUUID().toString());</span><br><span class="line">    RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> <span class="keyword">byte</span>[] testKeySerializeBytes = keySerializer.serialize(testKey);</span><br><span class="line">    <span class="keyword">if</span> (testKeySerializeBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"序列化testKey失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// testKey对应的原始值</span></span><br><span class="line">        String originalValue = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"testKey is &#123;&#125;"</span>, testKey);</span><br><span class="line"></span><br><span class="line">        ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置testKey一个值，因此testKey会存在与redis</span></span><br><span class="line">        stringStringValueOperations.set(testKey, originalValue);</span><br><span class="line">        logger.info(<span class="string">"testKey set value is &#123;&#125;,so the key is exist in redis"</span>, originalValue);</span><br><span class="line"></span><br><span class="line">        RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, <span class="keyword">new</span> Executable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 在testKey存在的情况下decr</span></span><br><span class="line">                Long decreaseValueReturn = stringRedisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">doInRedis</span><span class="params">(@Nullable RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BaseException(<span class="string">"链接Redis失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> connection.decr(testKeySerializeBytes);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                logger.info(<span class="string">"testKey decr ok and result is &#123;&#125;"</span>, decreaseValueReturn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        logger.error(<span class="string">"now is decr key value is not number exception"</span>, redisSystemException);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新获取testKey的值</span></span><br><span class="line">        String newValue = stringStringValueOperations.get(testKey);</span><br><span class="line">        logger.info(<span class="string">"after decr testKey`s value is &#123;&#125;"</span>, newValue);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后删除这个key，避免产生大量无用数据</span></span><br><span class="line">        stringRedisTemplate.delete(testKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/BITPOS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Redis文档">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/BITPOS/" itemprop="url">BITPOS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T17:31:04+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="BITPOS-key-bit-start-end"><a href="#BITPOS-key-bit-start-end" class="headerlink" title="BITPOS key bit [start] [end]"></a>BITPOS key bit [start] [end]</h3><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>返回字符串里面第一个被设置为1或者0的bit位。</p>
<p>返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。</p>
<p>GETBIT 和 SETBIT 相似的也是操作字节位的命令。</p>
<p>默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以start=0 并且 end=2是指前三个字节范围内查找。</p>
<p>注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。</p>
<p>和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。</p>
<p>不存在的key将会被当做空字符串来处理。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>支持版本: &gt;= 2.6.0</li>
<li>时间复杂度: O(N)</li>
<li>返回值: 命令返回字符串里面第一个被设置为1或者0的bit位。<br>如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。<br>如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。<br>基本上，我们可以把字符串看成右边有无数个0。<br>然而，如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。</li>
</ul>
<hr>
<h3 id="redis-cli-例子"><a href="#redis-cli-例子" class="headerlink" title="redis-cli 例子"></a>redis-cli 例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"\xff\xf0\x00"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 0 <span class="comment"># 查找字符串里面bit值为0的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">redis&gt; SET mykey <span class="string">"\x00\xff\xf0"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 1 0 <span class="comment"># 查找字符串里面bit值为1从第0个字节开始的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">redis&gt; BITPOS mykey 1 2 <span class="comment"># 查找字符串里面bit值为1从第2个字节(12)开始的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">redis&gt; <span class="built_in">set</span> mykey <span class="string">"\x00\x00\x00"</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; BITPOS mykey 1 <span class="comment"># 查找字符串里面bit值为1的位置</span></span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">Redis</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">125</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
