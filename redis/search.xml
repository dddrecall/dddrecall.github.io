<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Serializer for SpringBoot]]></title>
    <url>%2Fredis%2F2018%2F05%2F24%2Fserializer%2F</url>
    <content type="text"><![CDATA[解释通常我们有一些需求，需要让对象直接存储在Redis里面 以下就是举例使用序列化存储对象的例子 jdk 序列化首先是定义一个redisTemplate的Bean1234567891011121314151617/** * jdk（ObjectOutputStream，ObjectInputStream）序列化redis数据, 存储二进制字节码, 所以自定义序列化类 * * @param redisConnectionFactory redis链接工厂 * @return ResitTemplate */@Bean("jdkRedisTemplate")RedisTemplate&lt;Object, Object&gt; jdkRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); redisTemplate.setKeySerializer(new JdkSerializationRedisSerializer()); redisTemplate.setHashKeySerializer(new JdkSerializationRedisSerializer()); redisTemplate.setHashValueSerializer(new JdkSerializationRedisSerializer()); redisTemplate.afterPropertiesSet(); return redisTemplate;&#125; 可以注意到上面的redisTemplate的KeySerializer也是Jdk的序列化所以存储到Redis里面的key也会被序列化如需明文存储Key的时候，可以修改key的Serializer为StringRedisSerializer 下面是jdkRedisTemplate的例子12345678910111213141516171819@Test@DisplayName("jdkRedisTemplate测试")void jdkRedisTemplateTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID()); try &#123; logger.info("now is jdkRedisTemplate Test"); TestDTO testDTO = new TestDTO(); testDTO.setId(UUID.randomUUID().toString()); testDTO.setName(UUID.randomUUID().toString()); logger.info("testKey is &#123;&#125;", testKey); logger.info("the testKey value will set &#123;&#125;", testDTO); jdkRedisTemplate.opsForValue().set(testKey, testDTO); Object value = jdkRedisTemplate.opsForValue().get(testKey); assert value != null; logger.info("get testKey value from redis ,value type is &#123;&#125;,value content is &#123;&#125;", value.getClass().getSimpleName(), value); &#125; finally &#123; jdkRedisTemplate.delete(testKey); &#125;&#125; jackson方式首先是定义一个redisTemplate的Bean1234567891011121314151617181920212223/** * jackson 方式序列化redis 数据 * * @param redisConnectionFactory redis链接factory * @return ResitTemplate */@Bean("jacksonRedisTemplate")RedisTemplate&lt;Object, Object&gt; jacksonRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(jackson2JsonRedisSerializer); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); return redisTemplate;&#125; 下面是使用例子12345678910111213141516171819@Test@DisplayName("jacksonRedisTemplate测试")void jacksonRedisTemplateTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID()); try &#123; logger.info("now is jacksonRedisTemplate Test"); TestDTO testDTO = new TestDTO(); testDTO.setId(UUID.randomUUID().toString()); testDTO.setName(UUID.randomUUID().toString()); logger.info("testKey is &#123;&#125;", testKey); logger.info("the testKey value will set &#123;&#125;", testDTO); jacksonRedisTemplate.opsForValue().set(testKey, testDTO); Object value = jacksonRedisTemplate.opsForValue().get(testKey); assert value != null; logger.info("get testKey value from redis ,value type is &#123;&#125;,value content is &#123;&#125;", value.getClass().getSimpleName(), value); &#125; finally &#123; jacksonRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unwatch]]></title>
    <url>%2Fredis%2F2018%2F05%2F23%2Funwatch%2F</url>
    <content type="text"><![CDATA[语法1UNWATCH 解释刷新一个事务中已被监视的所有key(变为不监听了)。 如果执行EXEC 或者DISCARD， 则不需要手动执行UNWATCH 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: 总是 OK。 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[watch]]></title>
    <url>%2Fredis%2F2018%2F05%2F23%2Fwatch%2F</url>
    <content type="text"><![CDATA[语法1WATCH key [key ...] 解释标记所有指定的key 被监视起来，在事务中有条件的执行（乐观锁）。 扩展 支持版本: &gt;= WATCH key [key …] 时间复杂度: O(1) for every key. 返回值: 总是 OK。 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[discard]]></title>
    <url>%2Fredis%2F2018%2F05%2F23%2Fdiscard%2F</url>
    <content type="text"><![CDATA[语法1DISCARD 解释刷新一个事务中所有在排队等待的指令，并且将连接状态恢复到正常。(丢弃所有 MULTI 之后发的命令)如果已使用WATCH，DISCARD将释放所有被WATCH的key。 扩展 支持版本: &gt;= 2.0.0 返回值: 所有返回都是 OK redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exec]]></title>
    <url>%2Fredis%2F2018%2F05%2F23%2Fexec%2F</url>
    <content type="text"><![CDATA[语法1EXEC 解释执行事务中所有在排队等待的指令并将链接状态恢复到正常 当使用WATCH 时，只有当被监视的键没有被修改，且允许检查设定机制时，EXEC会被执行 扩展 支持版本: &gt;= 1.2.0 返回值: 每个元素与原子事务中的指令一一对应 当使用WATCH时，如果被终止，EXEC 则返回一个空的应答集合 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multi]]></title>
    <url>%2Fredis%2F2018%2F05%2F23%2Fmulti%2F</url>
    <content type="text"><![CDATA[语法1MULTI 解释标记一个事务块的开始。 随后的指令将在执行EXEC时作为一个原子执行。 扩展 支持版本: &gt;= 1.2.0 返回值: 始终为OK redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wait]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fwait%2F</url>
    <content type="text"><![CDATA[语法1WAIT numslaves timeout 解释此命令阻塞当前客户端，直到所有以前的写命令都成功的传输和指定的slaves确认。如果超时，指定以毫秒为单位，即使指定的slaves还没有到达，命令任然返回。 命令始终返回之前写命令发送的slaves的数量，无论是在指定slaves的情况还是达到超时。 注意点: 当’WAIT’返回时，所有之前的写命令保证接收由WAIT返回的slaves的数量。 如果命令呗当做事务的一部分发送，该命令不阻塞，而是只尽快返回先前写命令的slaves的数量。 如果timeout是0那意味着永远阻塞。 由于WAIT返回的是在失败和成功的情况下的slaves的数量。客户端应该检查返回的slaves的数量是等于或更大的复制水平。 一致性（一致性和等待)请注意，WAIT不会使Redis成为一个强大的一致性存储：虽然同步复制是复制状态机的一部分，但它不是唯一需要的。但是，在Sentinel或Redis群集故障转移的情况下，WAIT可以提高现实世界的数据安全性。 具体而言，如果给定的写入被传输到一个或多个从属设备，则更有可能（但不能保证），如果主设备出现故障，我们将能够在故障转移期间提升接收写入的从设备：Sentinel和Redis集群将尽最大努力尝试提升可用从属设备中的最佳从属设备。 但是，这只是尽力而为的尝试，所以仍然可能会丢失同步复制到多个从服务器的写入。 实施细节由于引入了与从节点的部分重新同步（PSYNC功能），Redis从节点使用它们已在复制流中处理的偏移量异步地对其主节点进行ping操作。这用于多种方式： 检测超时的奴隶。 断开连接后执行部分重新同步。 执行WAIT。在实现的特定情况下WAIT，Redis会记住，对于每个客户端，当给定写入命令在给定客户端的上下文中执行时，生成的复制流的复制偏移量。何时WAIT调用Redis检查指定数量的从站是否已经确认了此偏移量或更大的偏移量。 扩展 支持版本: &gt;= 3.0.0 时间复杂度: O(1) 返回值: integer-reply：该命令返回在当前连接上下文中执行的所有写操作所达到的从服务器的数量。 redis-cli 例子在以下示例中，第一次调用WAIT不使用超时，并要求写入达到1个从站。它返回成功。在第二次尝试中，我们放了一个超时，并要求将写入复制到两个从站。由于有一个可用的从站，在一秒钟后WAIT解除阻塞并返回1，达到了从站的数量。 123456&gt; SET foo barOK&gt; WAIT 1 0(integer) 1&gt; WAIT 2 1000(integer) 1 Spring Boot例子12]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[type]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Ftype%2F</url>
    <content type="text"><![CDATA[语法1TYPE key 解释返回key所存储的value的数据结构类型，它可以返回string, list, set, zset 和 hash等不同的类型。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1)s 返回值: 返回当前key的数据类型，如果key不存在时返回none。 redis-cli 例子12345678910111213redis&gt; SET key1 "value"OKredis&gt; LPUSH key2 "value"(integer) 1redis&gt; SADD key3 "value"(integer) 1redis&gt; TYPE key1stringredis&gt; TYPE key2listredis&gt; TYPE key3setredis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); DataType dataType = stringRedisTemplate.type(testKey); Assertions.assertNotNull(dataType); logger.info("TYPE testKey &gt; &#123;&#125;", dataType.name()); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); DataType dataType = stringRedisTemplate.type(testKey); Assertions.assertNotNull(dataType); logger.info("TYPE testKey &gt; &#123;&#125;", dataType.name()); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ttl]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fttl%2F</url>
    <content type="text"><![CDATA[语法1TTL key 解释返回key剩余的过期时间。 这种反射能力允许Redis客户端检查指定key在数据集里面剩余的有效期。 在Redis 2.6和之前版本，如果key不存在或者已过期时返回-1。 从Redis2.8开始，错误返回值的结果有如下改变： 如果key不存在或者已过期，返回 -2如果key存在并且没有设置过期时间（永久有效），返回 -1 。另见PTTL命令返回相同的信息，只不过他的时间单位是毫秒（仅适用于Redis 2.6及更高版本）。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: key有效的秒数（TTL in seconds）,或者一个负值的错误 (参考上文)。 redis-cli 例子1234567redis&gt; SET mykey "Hello"OKredis&gt; EXPIRE mykey 10 # 设置mykey 10秒后过期(integer) 1redis&gt; TTL mykey # 查看mykey剩余的过期时间(integer) 10redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在并且无过期时间时")void keyExistAndNoneExpireTimeTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.SECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key存在并且无过期时间时")void keyExistAndHaveExpireTimeTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); // EXPIRE testKey 10 stringRedisTemplate.expire(testKey, 10, TimeUnit.SECONDS); logger.info("SET testKey &#123;&#125;", value); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.SECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.SECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fsort%2F</url>
    <content type="text"><![CDATA[语法1SORT key [BY pattern] [LIMIT offset count] [GET pattern] [ASC|DESC] [ALPHA] destination 解释返回或存储key的list、 set 或sorted set 中的元素。默认是按照数值类型排序的，并且按照两个元素的双精度浮点数类型值进行比较。下面是SORT的最简形式：1SORT mylist 假设mylist是一个数字列表，这条命令将返回一个元素从小到大排序的相同大小列表。如果想从大到小排序，可以使用 !DESC 修饰符。1SORT mylist DESC 当 mylist 包含的是字符串值并且需要按照字典顺序排序，可以使用 ALPHA 修饰符：1SORT mylist ALPHA 假设正确地设置了环境变量 !LC_COLLATE ，Redis可以感知UTF-8编码。 返回元素的数量可以通过 LIMIT 修饰符限制。此修饰符有一个 offset 参数，指定了跳过的元素数量；还带有一个 count 参数，指定了从 offset 开始返回的元素数量。下面的例子将会返回排序后的列表 mylist 从第0个元素（offset 是从0开始的）开始的10个元素： 12345SORT mylist LIMIT 0 10``` 几乎所有的修饰符可以一起使用。下述例子将返回按字典顺序降序排序后的前5个元素：``` bashSORT mylist LIMIT 0 5 ALPHA DESC 通过外部key排序有时我们需要使用外部的key作为权重来排序，而不是使用列表、集合或有序集合中实际的元素值。假设列表 mylist包含元素1、 2 和 3，分别代表了存储在object_1、object_2 和 object_3中的对象的唯一ID。当这些对象关联到存储在weight_1、 weight_2 和 weight_3 中的权重后， SORT 命令就能使用这些权重按照下述语句来对 mylist 排序：1SORT mylist BY weight_* BY 选项带有一个模式（此例中的 weight_ ），用于生成用于排序的 Key 。这些key的名称指向首次与列表(本例中的1、 2 和 3)中元素的实际值出现 跳过排序的元素BY 选项可以是一个并不存在的key，这会导致 SORT 命令跳过排序操作。这在我们获取未经排序的外部key(参考下文的 GET 选项)时非常有用。1SORT mylist BY nosort 获取外部key前面的例子仅仅是返回排序后的ID。在某些情况下，获取实际的对象而不是他们的ID更加重要(object_1、object_2 和 object_3)。获取存储在一个列表、集合或者有序集合中的key可以使用以下命令：1SORT mylist BY weight_* GET object_* GET 选项可多次使用，以便获取每一个原始列表、集合或有序集合中元素的key。 还可以通过使用特殊 # 模式获取 GET 元素本身：1SORT mylist BY weight_* GET object_* GET # 保存排序操作的结果默认的，SORT 命令返回排序后的元素给客户端。使用 STORE 选项，可以将结果存储于一个特定的列表中，以代替返回到客户端。123456789SORT mylist BY weight_* STORE resultkey``` SORT ... STORE的一种有趣应用模式，是联合 EXPIRE 超时命令返回key，以便在应用中可以缓存SORT操作的返回结果。 其他客户端将会使用已缓存的列表，代替每个请求的 SORT 调用。当key即将过期时，一个更新版本的缓存将会通过 SORT ... STORE 再次创建。注意，为了正确实现这种模式，很重要的一点是防止多个客户端同时重建缓存。 此时需要使用一些锁（具体的使用 SETNX）。#### 在 BY 和 GET中使用hash ####可以在hash的属性上按下述语法使用 BY 和 GET 选项：``` bash SORT mylist BY weight_*-&gt;fieldname GET object_*-&gt;fieldname 字符串 -&gt; 用于区分key名称和哈希属性的名称。key被替换为上面所记录的，结果key中存储的hash用于获取特定hash的属性。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is currently O(N) as there is a copy step that will be avoided in next releases. 返回值: 返回排序后的元素列表 redis-cli 例子12 Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("排序截取")void orderSubTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); for (int i = 0; i &lt; 100; i++) &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().rightPush(testKey, value); logger.info("&#123;&#125;,RPUSH testKey &#123;&#125;", i, value); &#125; SortQueryBuilder&lt;String&gt; sortQueryBuilder = SortQueryBuilder.sort(testKey); // SORT 默认时按照数值类型比较 // 也就是说存的如果不是数字，须启用字典排序，否则会抛出异常 // 启用字典排序 sortQueryBuilder.alphabetical(true); // 设置起始位置和最大个数 sortQueryBuilder.limit(0, 50); SortQuery&lt;String&gt; stringSortQuery = sortQueryBuilder.build(); List&lt;String&gt; resultList = stringRedisTemplate.sort(stringSortQuery); logger.info("SORT testKey and condition json is &#123;&#125;", JSON.toJSONString(stringSortQuery)); Assertions.assertNotNull(resultList); for (int i = 0; i &lt; resultList.size(); i++) &#123; String value = resultList.get(i); logger.info("resultList[&#123;&#125;],value:&#123;&#125;", i, value); &#125; &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("排序截取储存")void orderSubStoreTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); String newStoreKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); for (int i = 0; i &lt; 100; i++) &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().rightPush(testKey, value); logger.info("&#123;&#125;,RPUSH testKey &#123;&#125;", i, value); &#125; newStoreKey = String.format("testKey:%s", UUID.randomUUID().toString()); SortQueryBuilder&lt;String&gt; sortQueryBuilder = SortQueryBuilder.sort(testKey); // 启用字典排序 sortQueryBuilder.alphabetical(true); // 设置起始位置和最大个数 sortQueryBuilder.limit(0, 50); SortQuery&lt;String&gt; stringSortQuery = sortQueryBuilder.build(); logger.info("stringSortQuery is &#123;&#125;", JSON.toJSONString(stringSortQuery)); Long storeCount = stringRedisTemplate.sort(stringSortQuery, newStoreKey); logger.info("STORE testKey condition STORE newStoreKey &gt; &#123;&#125;", storeCount); // 获得newStoreKey的所有元素 (0代表第一个元素,-1标识最后一个元素,-2则表示倒数第二个元素) List&lt;String&gt; resultList = stringRedisTemplate.opsForList().range(newStoreKey, 0, -1); Assertions.assertNotNull(resultList); for (int i = 0; i &lt; resultList.size(); i++) &#123; String value = resultList.get(i); logger.info("resultList[&#123;&#125;],value:&#123;&#125;", i, value); &#125; &#125; finally &#123; try &#123; stringRedisTemplate.delete(testKey); &#125; finally &#123; if (newStoreKey != null) &#123; stringRedisTemplate.delete(newStoreKey); &#125; &#125; &#125;&#125;@Test@DisplayName("通过外部KEY排序")void orderByOutKeyTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); List&lt;String&gt; weightKeyList = new ArrayList&lt;&gt;(); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); for (int i = 0; i &lt; 100; i++) &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().rightPush(testKey, value); logger.info("&#123;&#125;,RPUSH testKey &#123;&#125;", i, value); String weightKey = String.format("weight:%s", value); weightKeyList.add(weightKey); stringRedisTemplate.opsForValue().set(weightKey, Integer.valueOf(i).toString()); &#125; SortQueryBuilder&lt;String&gt; sortQueryBuilder = SortQueryBuilder.sort(testKey); // 设置起始位置和最大个数 sortQueryBuilder.limit(0, 50); // 降序排序 sortQueryBuilder.order(SortParameters.Order.ASC); // weight:* 其中的*最终会转化为当前排序的元素 // 然后通过这个key在REDIS里面GET，然后以GET结果数值进行元素排序 // 有点SQL的连表排序的意思 sortQueryBuilder.by("weight:*"); SortQuery&lt;String&gt; stringSortQuery = sortQueryBuilder.build(); List&lt;String&gt; resultList = stringRedisTemplate.sort(stringSortQuery); logger.info("SORT testKey and condition json is &#123;&#125;", JSON.toJSONString(stringSortQuery)); Assertions.assertNotNull(resultList); for (int i = 0; i &lt; resultList.size(); i++) &#123; String value = resultList.get(i); logger.info("resultList[&#123;&#125;],value:&#123;&#125;", i, value); &#125; &#125; finally &#123; try &#123; stringRedisTemplate.delete(testKey); &#125; finally &#123; stringRedisTemplate.delete(weightKeyList); &#125; &#125;&#125;@Test@DisplayName("跳过排序")void noSort() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); for (int i = 0; i &lt; 100; i++) &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().rightPush(testKey, value); logger.info("&#123;&#125;,RPUSH testKey &#123;&#125;", i, value); &#125; SortQueryBuilder&lt;String&gt; sortQueryBuilder = SortQueryBuilder.sort(testKey); // 不排序 // 实际转化为命令是by 一个不存在的key sortQueryBuilder.noSort(); // 设置起始位置和最大个数 sortQueryBuilder.limit(0, 50); SortQuery&lt;String&gt; stringSortQuery = sortQueryBuilder.build(); List&lt;String&gt; resultList = stringRedisTemplate.sort(stringSortQuery); logger.info("SORT testKey and condition json is &#123;&#125;", JSON.toJSONString(stringSortQuery)); Assertions.assertNotNull(resultList); for (int i = 0; i &lt; resultList.size(); i++) &#123; String value = resultList.get(i); logger.info("resultList[&#123;&#125;],value:&#123;&#125;", i, value); &#125; &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("获取外部key的值")void getOutValue() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); List&lt;String&gt; weightKeyList = new ArrayList&lt;&gt;(); List&lt;String&gt; objectKeyList = new ArrayList&lt;&gt;(); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); for (int i = 0; i &lt; 100; i++) &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().rightPush(testKey, value); logger.info("&#123;&#125;,RPUSH testKey &#123;&#125;", i, value); String weightKey = String.format("weight:%s", value); String weightValue = Integer.valueOf(i).toString(); stringRedisTemplate.opsForValue().set(weightKey, weightValue); weightKeyList.add(weightKey); logger.info("weightKey:&#123;&#125;,weightValue:&#123;&#125;", weightKey, weightValue); String objectKey = String.format("object:%s", value); String objectValue = String.format("[%d][%s]", i, UUID.randomUUID()); stringRedisTemplate.opsForValue().set(objectKey, objectValue); objectKeyList.add(objectValue); logger.info("objectKey:&#123;&#125;,objectValue:&#123;&#125;", objectKey, objectValue); &#125; SortQueryBuilder&lt;String&gt; sortQueryBuilder = SortQueryBuilder.sort(testKey); // 设置起始位置和最大个数 sortQueryBuilder.limit(0, 50); // 降序排序 sortQueryBuilder.order(SortParameters.Order.DESC); // weight:* 其中的*最终会转化为当前排序的元素 // 然后通过这个key在Redis里面GET，然后以GET结果数值进行元素排序 // 有点SQL的连表排序的意思 sortQueryBuilder.by("weight:*"); // object:* 其中*最终会转化为当前排序的元素 // 排序之后，返回值就会变为去Redis,GET object:* 的返回值 // 也就说如果最终转化的object:xxx 如果在Redis不存在则返回的列表会包含空的元素 sortQueryBuilder.get("object:*"); SortQuery&lt;String&gt; stringSortQuery = sortQueryBuilder.build(); List&lt;String&gt; resultList = stringRedisTemplate.sort(stringSortQuery); logger.info("SORT testKey and condition json is &#123;&#125;", JSON.toJSONString(stringSortQuery)); Assertions.assertNotNull(resultList); for (int i = 0; i &lt; resultList.size(); i++) &#123; String value = resultList.get(i); logger.info("resultList[&#123;&#125;],value:&#123;&#125;", i, value); &#125; &#125; finally &#123; try &#123; stringRedisTemplate.delete(testKey); &#125; finally &#123; try &#123; stringRedisTemplate.delete(weightKeyList); &#125; finally &#123; stringRedisTemplate.delete(objectKeyList); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scan]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fscan%2F</url>
    <content type="text"><![CDATA[语法1SCAN cursor [MATCH pattern] [COUNT count] 解释SCAN 命令及其相关的 SSCAN, HSCAN 和 ZSCAN 命令都用于增量迭代一个集合元素。 SCAN 命令用于迭代当前数据库中的key集合。 SSCAN 命令用于迭代SET集合中的元素。 HSCAN 命令用于迭代Hash类型中的键值对。 ZSCAN 命令用于迭代SortSet集合中的元素和元素对应的分值以上列出的四个命令都支持增量式迭代，它们每次执行都只会返回少量元素，所以这些命令可以用于生产环境，而不会出现像 KEYS 或者 SMEMBERS 命令带来的可能会阻塞服务器的问题。 不过，SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于SCAN这类增量式迭代命令来说，有可能在增量迭代过程中，集合元素被修改，对返回值无法提供完全准确的保证。 因为 SCAN, SSCAN, HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令，需要注意的是SSCAN, HSCAN ,ZSCAN命令的第一个参数总是一个key； SCAN 命令则不需要在第一个参数提供任何key，因为它迭代的是当前数据库中的所有key。 SCAN命令的基本用法SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程 当SCAN命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。 以下是一个 SCAN 命令的迭代过程示例 :123456789101112131415161718192021222324redis 127.0.0.1:6379&gt; scan 01) "17"2) 1) "key:12" 2) "key:8" 3) "key:4" 4) "key:14" 5) "key:16" 6) "key:17" 7) "key:15" 8) "key:10" 9) "key:3" 10) "key:7" 11) "key:1"redis 127.0.0.1:6379&gt; scan 171) "0"2) 1) "key:5" 2) "key:18" 3) "key:0" 4) "key:2" 5) "key:19" 6) "key:13" 7) "key:6" 8) "key:9" 9) "key:11" 在上面这个例子中， 第一次迭代使用 0 作为游标， 表示开始一次新的迭代。第二次迭代使用的是第一次迭代时返回的游标 17 ，作为新的迭代参数 。 显而易见，SCAN命令的返回值 是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。 在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集已经被完整遍历过了。 full iteration ：以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。 Scan命令的保证SCAN命令以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证 ： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。 同样，如果一个元素在开始遍历之前被移出集合，并且在遍历开始直到遍历结束期间都没有再加入，那么在遍历返回的元素集中就不会出现该元素。然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有以下缺点： 同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。 如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会。 SCAN命令每次执行返回的元素数量SCAN增量式迭代命令并不保证每次执行都返回某个给定数量的元素,甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。 不过命令返回的元素数量总是符合一定规则的， 对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（小的sets, hashes and sorted sets）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。 如果需要的话，用户可以通过增量式迭代命令提供的COUNT选项来指定每次迭代返回元素的最大值。 COUNT选项对于增量式迭代命令不保证每次迭代所返回的元素数量，我们可以使用COUNT选项， 对命令的行为进行一定程度上的调整。COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。使用COUNT 选项对于对增量式迭代命令相当于一种提示， 大多数情况下这种提示都比较有效的控制了返回值的数量。 COUNT 参数的默认值为 10 。 数据集比较大时，如果没有使用MATCH 选项, 那么命令返回的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。 在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给用户。注意: 并非每次迭代都要使用相同的 COUNT 值 ，用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。MATCH 选项类似于KEYS 命令，增量式迭代命令通过给定 MATCH 参数的方式实现了通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素。 以下是一个使用 MATCH 选项进行迭代的示例:12345678redis 127.0.0.1:6379&gt; sadd myset 1 2 3 foo foobar feelsgood(integer) 6redis 127.0.0.1:6379&gt; sscan myset 0 match f*1) "0"2) 1) "foo" 2) "feelsgood" 3) "foobar"redis 127.0.0.1:6379&gt; MATCH功能对元素的模式匹配工作是在命令从数据集中取出元素后和向客户端返回元素前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。 以下是这种情况的一个例子:123456789101112131415161718192021222324252627282930313233redis 127.0.0.1:6379&gt; scan 0 MATCH *11*1) "288"2) 1) "key:911"redis 127.0.0.1:6379&gt; scan 288 MATCH *11*1) "224"2) (empty list or set)redis 127.0.0.1:6379&gt; scan 224 MATCH *11*1) "80"2) (empty list or set)redis 127.0.0.1:6379&gt; scan 80 MATCH *11*1) "176"2) (empty list or set)redis 127.0.0.1:6379&gt; scan 176 MATCH *11* COUNT 10001) "0"2) 1) "key:611" 2) "key:711" 3) "key:118" 4) "key:117" 5) "key:311" 6) "key:112" 7) "key:111" 8) "key:110" 9) "key:113" 10) "key:211" 11) "key:411" 12) "key:115" 13) "key:116" 14) "key:114" 15) "key:119" 16) "key:811" 17) "key:511" 18) "key:11"redis 127.0.0.1:6379&gt; 可以看出，以上的大部分迭代都不返回任何元素。在最后一次迭代， 我们通过将 COUNT 选项的参数设置为 1000 ， 强制命令为本次迭代扫描更多元素， 从而使得命令返回的元素也变多了。 并发执行多个迭代在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。 中止迭代因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。即使有任意数量的迭代在中途停止， 也不会产生任何问题。 使用错误的游标使用SCAN 命令传入间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。 只有两种游标是合法的: 在开始一个新的迭代时， 游标必须为 0 。 增量式迭代命令在执行之后返回的， 用于延续迭代过程的游标。迭代能终止的前提增量式迭代命令所使用的算法只保证在数据集的大小有界的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。 从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。 扩展 支持版本: &gt;= 2.8.0 时间复杂度: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection. 返回值: SCAN, SSCAN, HSCAN 和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： 回复的第一个元素是字符串表示的无符号 64 位整数（游标）， 回复的第二个元素是另一个 multi-bulk 回复， 包含了本次被迭代的元素。 SCAN 命令返回的每个元素都是一个key。 SSCAN 命令返回的每个元素都是一个集合成员。 HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。 ZSCAN命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。 redis-cli 例子迭代hash中的键值对12345678redis 127.0.0.1:6379&gt; hmset hash name Jack age 33OKredis 127.0.0.1:6379&gt; hscan hash 01) "0"2) 1) "name" 2) "Jack" 3) "age" 4) "33" Spring Boot例子12345678910111213141516171819202122232425262728private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; // key的匹配规则 String pattern = "*"; // 最大返回个数 int count = 1000; ScanOptions options = ScanOptions.scanOptions().match(pattern).count(count).build(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123; Cursor&lt;byte[]&gt; cursor = connection.scan(options); // 由于hasNext源码里面会自动进行再次scan // 所以不用担心只能scan一次 // 每次scan后 会把cursor的iterator替换为此次scan结果的iterator // 所以也不用担心之前的数据一直还存在同一个iterator while (cursor.hasNext()) &#123; String item = valueSerializer.deserialize(cursor.next()); logger.info("scan[&#123;&#125;] item:&#123;&#125;", cursor.getCursorId(), item); &#125; return null; &#125;);&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[renamenx]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Frenamenx%2F</url>
    <content type="text"><![CDATA[语法1RENAMENX key newkey 解释当且仅当 newkey 不存在时，将 key 改名为 newkey 。 当 key 不存在时，返回一个错误。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 修改成功时，返回 1 。 如果 newkey 已经存在，返回 0 。 redis-cli 例子123456789redis&gt; SET mykey "Hello"OKredis&gt; SET myotherkey "World"OKredis&gt; RENAMENX mykey myotherkey(integer) 0redis&gt; GET myotherkey"World"redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); String newTesKey = String.format("testKey:%s", UUID.randomUUID().toString()); Boolean result = stringRedisTemplate.renameIfAbsent(testKey, newTesKey); logger.info("RENAMENX testKey &#123;&#125; &gt; &#123;&#125;", newTesKey, result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123; logger.info("now random testKey is &#123;&#125;", testKey); String newTesKey = String.format("testKey:%s", UUID.randomUUID().toString()); // 如果当testKey(oldKey) 不存在的时候,会抛出一个异常 Boolean result = stringRedisTemplate.renameIfAbsent(testKey, newTesKey); logger.info("RENAMENX testKey &#123;&#125; &gt; &#123;&#125;", newTesKey, result); &#125;); logger.error("redisSystemException", redisSystemException);&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rename]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Frename%2F</url>
    <content type="text"><![CDATA[语法1RENAME key newkey 解释将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: OK redis-cli 例子1234567redis&gt; SET mykey "Hello"OKredis&gt; RENAME mykey myotherkeyOKredis&gt; GET myotherkey"Hello"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("新key不存在时")void newKeyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); // RENAME testKey newTestKey String newTestKey = String.format("testKey:%s", UUID.randomUUID().toString()); stringRedisTemplate.rename(testKey, newTestKey); logger.info("RENAME testKey newTestKey"); String newTestKeyValue = stringRedisTemplate.opsForValue().get(newTestKey); logger.info("GET newTestKey result is &#123;&#125;", newTestKeyValue); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("新key存在时")void newKeyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); // RENAME testKey newTestKey String newTestKey = String.format("testKey:%s", UUID.randomUUID().toString()); String newTestKeyValue = UUID.randomUUID().toString(); // SET newTestKey newTestKeyValue logger.info("SET newTestKey &#123;&#125;", newTestKeyValue); stringRedisTemplate.rename(testKey, newTestKey); logger.info("RENAME testKey newTestKey"); newTestKeyValue = stringRedisTemplate.opsForValue().get(newTestKey); logger.info("GET newTestKey result is &#123;&#125;", newTestKeyValue); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[randomkey]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Frandomkey%2F</url>
    <content type="text"><![CDATA[语法1RANDOMKEY 解释从当前数据库返回一个随机的key。 扩展 支持版本: &gt;= RANDOMKEY 时间复杂度: O(1) 返回值: 如果数据库没有任何key，返回nil，否则返回一个随机的key redis-cli 例子12 Spring Boot例子1234567891011private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试用例")void genericTest() &#123; String randomKey = stringRedisTemplate.randomKey(); logger.info("randomKey is &#123;&#125;",randomKey);&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pttl]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fpttl%2F</url>
    <content type="text"><![CDATA[语法1PTTL key 解释这个命令类似于TTL命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像TTL命令那样，以秒为单位。 在Redis 2.6和之前版本，如果key不存在或者key存在且无过期时间将返回-1。 从 Redis 2.8开始，错误返回值发送了如下变化： 如果key不存在返回-2 如果key存在且无过期时间返回-1 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: TTL以毫秒为单位,或者返回一个错误值 (参考上面的描述). redis-cli 例子1234567redis&gt; SET mykey "Hello"OKredis&gt; EXPIRE mykey 1(integer) 1redis&gt; PTTL mykey(integer) 999redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在并且无过期时间时")void keyExistAndNoneExpireTimeTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.MILLISECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key存在并且无过期时间时")void keyExistAndHaveExpireTimeTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); // EXPIRE testKey 10 stringRedisTemplate.expire(testKey, 10, TimeUnit.SECONDS); logger.info("SET testKey &#123;&#125;", value); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.MILLISECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); Long result = stringRedisTemplate.getExpire(testKey, TimeUnit.MILLISECONDS); logger.info("PTTL testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pexpireat]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fpexpireat%2F</url>
    <content type="text"><![CDATA[语法1PEXPIREAT key milliseconds-timestamp 解释PEXPIREAT 这个命令和EXPIREAT命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像EXPIREAT那样，以秒为单位。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: 如果生存时间设置成功，返回 1 。 当 key 不存在或没办法设置生存时间时，返回 0 。 (查看: EXPIRE命令获取更多信息). redis-cli 例子123456789redis&gt; SET mykey "Hello"OKredis&gt; PEXPIREAT mykey 1555555555005(integer) 1redis&gt; TTL mykey(integer) 192569170redis&gt; PTTL mykey(integer) 192569169649redis&gt; Spring Boot例子1234567891011121314151617181920212223242526272829303132333435363738394041private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); Assertions.assertNotNull(testKeySerializeBytes); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.pExpireAt(testKeySerializeBytes, new Date().getTime())); logger.info("PEXPIREAT testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); Assertions.assertNotNull(testKeySerializeBytes); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.pExpireAt(testKeySerializeBytes, new Date().getTime())); logger.info("PEXPIREAT testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pexpire]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fpexpire%2F</url>
    <content type="text"><![CDATA[语法1这个命令和EXPIRE命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像EXPIRE命令那样，以秒为单位。 解释这个命令和EXPIRE命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像EXPIRE命令那样，以秒为单位。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: 设置成功，返回 1 key 不存在或设置失败，返回 0 redis-cli 例子123456789redis&gt; SET mykey "Hello"OKredis&gt; PEXPIRE mykey 1500(integer) 1redis&gt; TTL mykey(integer) 1redis&gt; PTTL mykey(integer) 1499redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); Assertions.assertNotNull(testKeySerializeBytes); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.pExpire(testKeySerializeBytes, 1000)); logger.info("PEXPIRE testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); Assertions.assertNotNull(testKeySerializeBytes); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.pExpire(testKeySerializeBytes, 1000)); logger.info("PEXPIRE testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[persist]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fpersist%2F</url>
    <content type="text"><![CDATA[语法1PERSIST key 解释移除给定key的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。 扩展 支持版本: &gt;= PERSIST key 时间复杂度: O(1) 返回值: 只有以下两种值: 当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 . redis-cli 例子1234567891011redis&gt; SET mykey "Hello"OKredis&gt; EXPIRE mykey 10(integer) 1redis&gt; TTL mykey(integer) 10redis&gt; PERSIST mykey(integer) 1redis&gt; TTL mykey(integer) -1redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key有过期时间时")void keyHaveExpireTime() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); // EXPIRE testKey 10 s stringRedisTemplate.expire(testKey, 10, TimeUnit.SECONDS); // 移除过期时间 Boolean result = stringRedisTemplate.persist(testKey); logger.info("PERSIST testKey result &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key无过期时间")void keyNotHaveExpireTime() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("SET testKey &#123;&#125;", value); // 移除过期时间 Boolean result = stringRedisTemplate.persist(testKey); logger.info("PERSIST testKey result &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[move]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fmove%2F</url>
    <content type="text"><![CDATA[语法1MOVE key db 解释将当前数据库的 key 移动到给定的数据库 db 当中。 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 移动成功返回 1 失败则返回 0 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[migrate]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fmigrate%2F</url>
    <content type="text"><![CDATA[语法1MIGRATE host port key destination-db timeout [COPY] [REPLACE] 解释将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。 命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。 timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。 MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。 当 IOERR 出现时，有以下两种可能： key 可能存在于两个实例。 key 可能只存在于当前实例。唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE, 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。 如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。 扩展 支持版本: &gt;= 2.6.0 时间复杂度:This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed. 返回值: 迁移成功时返回 OK ，否则返回相应的错误。 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keys]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fkeys%2F</url>
    <content type="text"><![CDATA[语法12 解释查找所有符合给定模式pattern（正则表达式）的 key 。 时间复杂度为O(N)，N为数据库里面key的数量。 例如，Redis在一个有1百万个key的数据库里面执行一次查询需要的时间是40毫秒 。 警告: KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 KEYS， 你最好还是用 Redis 的集合结构 SETS 来代替。 支持的正则表达模式： h?llo 匹配 hello, hallo 和 hxlloh*llo 匹配 hllo 和 heeeelloh[ae]llo 匹配 hello 和 hallo, 但是不匹配 hilloh[^e]llo 匹配 hallo, hbllo, … 但是不匹配 helloh[a-b]llo 匹配 hallo 和 hbllo如果你想取消字符的特殊匹配（正则表达式，可以在它的前面加\。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length. 返回值: 所有符合条件的key redis-cli 例子1234567891011121314redis&gt; MSET one 1 two 2 three 3 four 4OKredis&gt; KEYS *o*1) "four"2) "one"3) "two"redis&gt; KEYS t??1) "two"redis&gt; KEYS *1) "four"2) "three"3) "one"4) "two"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[expireat]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fexpireat%2F</url>
    <content type="text"><![CDATA[语法1EXPIREAT key timestamp 解释EXPIREAT 的作用和 EXPIRE类似，都用于为 key 设置生存时间。不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳 Unix timestamp 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(1) 返回值: 如下的整数结果 1 如果设置了过期时间 0 如果没有设置过期时间，或者不能设置过期时间 redis-cli 例子123456789redis&gt; SET mykey "Hello"OKredis&gt; EXISTS mykey(integer) 1redis&gt; EXPIREAT mykey 1293840000(integer) 1redis&gt; EXISTS mykey(integer) 0redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("set testKey &#123;&#125;", value); Boolean result = stringRedisTemplate.expireAt(testKey, new Date()); logger.info("expireat testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); Boolean result = stringRedisTemplate.expireAt(testKey, new Date()); logger.info("expireat testKey result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exists]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fexists%2F</url>
    <content type="text"><![CDATA[语法1EXISTS key [key ...] 解释返回key是否存在。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 1 如果key存在 0 如果key不存在 redis-cli 例子1234567redis&gt; SET key1 "Hello"OKredis&gt; EXISTS key1(integer) 1redis&gt; EXISTS key2(integer) 0redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); logger.info("random testKey now is &#123;&#125;", testKey); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); try &#123; Assertions.assertNotNull(testKeySerializeBytes); String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForValue().set(testKey, value); logger.info("set testKey &#123;&#125;", value); Boolean exists = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.exists(testKeySerializeBytes)); logger.info("exists testKey result is &#123;&#125;", exists); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在的时")void keyNotExists()&#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); logger.info("random testKey now is &#123;&#125;", testKey); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); try &#123; Assertions.assertNotNull(testKeySerializeBytes); Boolean exists = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.exists(testKeySerializeBytes)); logger.info("exists testKey result is &#123;&#125;", exists); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[del]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fdel%2F</url>
    <content type="text"><![CDATA[语法1DEL key [key ...] 解释删除指定的一批keys，如果删除中的某些key不存在，则直接忽略。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) 将要被删除的key的数量，当删除的key是字符串以外的复杂数据类型时比如List,Set,Hash删除这个key的时间复杂度是O(1)。 返回值: 被删除的keys的数量 redis-cli 例子1234567redis&gt; SET key1 "Hello"OKredis&gt; SET key2 "World"OKredis&gt; DEL key1 key2 key3(integer) 2redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); logger.info("now random testKey is &#123;&#125;", testKey); try &#123; String value = UUID.randomUUID().toString(); stringRedisTemplate.opsForValue().set(testKey, value); logger.info("set testKey &#123;&#125;", value); &#125; finally &#123; Boolean delete = stringRedisTemplate.delete(testKey); logger.info("del testKey result is &#123;&#125;", delete); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); &#125; finally &#123; Boolean delete = stringRedisTemplate.delete(testKey); logger.info("del testKey result is &#123;&#125;", delete); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script-load]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fscript-load%2F</url>
    <content type="text"><![CDATA[语法1SCRIPT LOAD script 解释将脚本加载到脚本缓存中，而不执行它。在将指定的命令加载到脚本缓存中之后，将使用EVALSHA和脚本的正确SHA1摘要来调用它，就像在第一次成功调用EVAL之后一样。 该脚本被保证永远留在脚本缓存中（除非SCRIPT FLUSH被调用）。 即使该脚本已存在于脚本缓存中，该命令也可以以相同的方式工作。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O（N），其中N是脚本主体的字节长度。 返回值: 此命令返回添加到脚本缓存中的脚本的SHA1摘要。 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script-kill]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fscript-kill%2F</url>
    <content type="text"><![CDATA[语法1SCRIPT KILL 解释杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。 SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL 命令的阻塞当中退出，并收到一个错误作为返回值。 另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: OK redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script-flush]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fscript-flush%2F</url>
    <content type="text"><![CDATA[语法1SCRIPT FLUSH 解释清空Lua脚本缓存 Flush the Lua scripts cache. 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(N) with N being the number of scripts in cache 返回值: OK redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[script-exists]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fscript-exists%2F</url>
    <content type="text"><![CDATA[语法1SCRIPT EXISTS script [script ...] 解释检查脚本是否存在脚本缓存里面。 这个命令可以接受一个或者多个脚本SHA1信息，返回一个1或者0的列表，如果脚本存在或不存在。 还可以使用管道技术（pipelining operation）确保脚本加载（也可以使用SCRIPT LOAD）， 管道技术可以单独使用EVALSHA来代替EVAL，从而节省带宽（bandwidth）。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O（N），其中N是要检查的脚本的数量（因此检查单个脚本是O（1）操作）。 返回值: 命令返回对应于每一个SHA1的数组，脚本存在返回1，不存在的返回0。 redis-cli 例子12 Spring Boot例子12]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[evalsha]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fevalsha%2F</url>
    <content type="text"><![CDATA[语法1EVALSHA sha1 numkeys key [key ...] arg [arg ...] 解释根据给定的 SHA1 校验码，对缓存在服务器中的脚本进行求值。 将脚本缓存到服务器的操作可以通过 SCRIPT LOAD 命令进行。 这个命令的其他地方，比如参数的传入方式，都和 EVAL命令一样。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: 取决于脚本本身的执行的时间复杂度。]]></content>
      <tags>
        <tag>script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zunionstore]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzunionstore%2F</url>
    <content type="text"><![CDATA[语法1ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] 解释计算给定的numkeys个有序集合的并集，并且把结果放到destination中。在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果集中某个成员的score值是所有给定集下该成员score值之和。 使用WEIGHTS选项，你可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认就是1。 使用AGGREGATE选项，你可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中元素最小或最大的元素。 如果key destination存在，就被覆盖。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O（N）+ O（M log（M）），其中N是输入排序集合的大小之和，M是结果排序集合中元素的数量。 返回值: 结果排序集destination中的元素数量 redis-cli 例子123456789101112131415161718redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREVRANGEBYSCORE myzset +inf -inf1) "three"2) "two"3) "one"redis&gt; ZREVRANGEBYSCORE myzset 2 11) "two"2) "one"redis&gt; ZREVRANGEBYSCORE myzset 2 (11) "two"redis&gt; ZREVRANGEBYSCORE myzset (2 (1(empty list or set)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zscore]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzscore%2F</url>
    <content type="text"><![CDATA[语法1ZSCORE key member 解释返回member有序集合处的得分key。如果member在有序集合key中不存在或不存在，nil则返回。 扩展 支持版本: &gt;= 1.2.0. 时间复杂度: O(1) 返回值: （member双精度浮点数）的分数，表示为字符串。 redis-cli 例子12345redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZSCORE myzset "one""1"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zscan]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzscan%2F</url>
    <content type="text"><![CDATA[语法1ZSCAN key cursor [MATCH pattern] [COUNT count] 解释请查看SACN的文档 扩展 支持版本: &gt;= 2.8.0 时间复杂度: O（1）用于每个呼叫。O（N）进行完整的迭代，包括足够的命令调用以使游标返回0. N是集合中元素的数量。]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrevrank]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrevrank%2F</url>
    <content type="text"><![CDATA[语法1ZREVRANK key member 解释返回member存储在排序集合中的排名，key分数从高到低排序。等级（或指数）是基于0的，这意味着具有最高分数的成员具有等级0。 使用ZRANK获得排序从低到高的元素的排名。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(log(N)) 返回值: 如果member存在于已排序的集合中，则整数回复：member的排名。 如果member在有序集合key中不存在或不存在，则 批量字符串回复：nil。 redis-cli 例子1234567891011redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREVRANK myzset "one"(integer) 2redis&gt; ZREVRANK myzset "four"(nil)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrevrangebyscore]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrevrangebyscore%2F</url>
    <content type="text"><![CDATA[语法1ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count] 解释以及key之间的分数返回排序集合中的所有元素（包括分数等于或的元素）。与排序集的默认排序相反，对于此命令，这些元素被认为是从高分到低排序。 具有相同分数的元素按照反向字典顺序返回。 除了颠倒的顺序之外，ZREVRANGEBYSCORE与ZRANGEBYSCORE相似 。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O（log（N）+ M），其中N是有序集合中元素的数量，M是返回元素的数量。如果M是常量（例如，总是要求使用LIMIT的前10个元素），则可以将其视为O（log（N））。 返回值: 指定分数范围内的元素列表（可选择其分数）。 redis-cli 例子123456789101112131415161718redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREVRANGEBYSCORE myzset +inf -inf1) "three"2) "two"3) "one"redis&gt; ZREVRANGEBYSCORE myzset 2 11) "two"2) "one"redis&gt; ZREVRANGEBYSCORE myzset 2 (11) "two"redis&gt; ZREVRANGEBYSCORE myzset (2 (1(empty list or set)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrevrange]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrevrange%2F</url>
    <content type="text"><![CDATA[语法1ZREVRANGE key start stop [WITHSCORES] 解释返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列。具有相同score值的成员按字典序的反序排列。 除了成员按score值递减的次序排列这一点外，ZREVRANGE命令的其他方面和ZRANGE命令一样。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O（log（N）+ M），其中N是有序集合中元素的数量，M是返回元素的数量。 返回值: 指定范围内的元素列表（可选择其分数）。 redis-cli 例子12345678910111213141516redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREVRANGE myzset 0 -11) "three"2) "two"3) "one"redis&gt; ZREVRANGE myzset 2 31) "one"redis&gt; ZREVRANGE myzset -2 -11) "two"2) "one"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zremrangebyscore]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzremrangebyscore%2F</url>
    <content type="text"><![CDATA[语法1ZREMRANGEBYSCORE key min max 解释key以分数min和max（包括）之间的分数 移除存储在分类集中的所有元素。 自从2.1.6版本，min并max可以独享，语法如下 ZRANGEBYSCORE。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O（log（N）+ M），其中N是已排序集合中元素的数量，M是由操作移除的元素数量。 返回值: 删除的元素数量。 redis-cli 例子1234567891011121314redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREMRANGEBYSCORE myzset -inf (2(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) "two"2) "2"3) "three"4) "3"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zremrangebyrank]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzremrangebyrank%2F</url>
    <content type="text"><![CDATA[语法1ZREMRANGEBYRANK key start stop 解释删除存储在排序集中key且等级介于start和stop之间的所有元素。双方start并stop都0与基指数0是得分最低的元素。这些索引可以是负数，它们表示从得分最高的元素开始的偏移。例如：-1分数最高-2的元素，分数第二高的元素等等。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O（log（N）+ M），其中N是已排序集合中元素的数量，M是由操作移除的元素数量。 返回值: 删除的元素数量。 redis-cli 例子123456789101112redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREMRANGEBYRANK myzset 0 1(integer) 2redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) "three"2) "3"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zremrangebylex]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzremrangebylex%2F</url>
    <content type="text"><![CDATA[语法1ZREMRANGEBYLEX key min max 解释ZREMRANGEBYLEX 删除名称按字典由低到高排序成员之间所有成员。不要在成员分数不同的有序集合中使用此命令, 因为它是基于分数一致的有序集合设计的,如果使用,会导致删除的结果不正确。待删除的有序集合中,分数最好相同,否则删除结果会不正常。 说明 指令 是否必须 说明 key 是 有序集合键名称 min 是 字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替 max 是 字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替 扩展 支持版本: &gt;= 2.8.9 时间复杂度: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation. 返回值: 删除元素的个数。 redis-cli 例子123456789101112131415161718192021222324redis&gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e(integer) 5redis&gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha(integer) 5redis&gt; ZRANGE myzset 0 -11) "ALPHA" 2) "aaaa" 3) "alpha" 4) "b" 5) "c" 6) "d" 7) "e" 8) "foo" 9) "zap"10) "zip"redis&gt; ZREMRANGEBYLEX myzset [alpha [omega(integer) 6redis&gt; ZRANGE myzset 0 -11) "ALPHA"2) "aaaa"3) "zap"4) "zip"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrem]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrem%2F</url>
    <content type="text"><![CDATA[语法1ZREM key member [member ...] 解释从存储的已排序集中移除指定的成员key。不存在的成员被忽略。当key存在，但是其不是有序集合类型，就返回一个错误。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed. 返回值: 返回的是从有序集合中删除的成员个数，不包括不存在的成员。 历史: 在2.4之前的版本中，每次只能删除一个成员。 redis-cli 例子1234567891011121314redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZREM myzset "two"(integer) 1redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) "one"2) "1"3) "three"4) "3"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrank]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrank%2F</url>
    <content type="text"><![CDATA[语法1ZRANK key member 解释返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。 使用ZREVRANK命令可以获得成员按score值递减(从大到小)排列的排名。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(log(N)) 返回值: 如果member是有序集key的成员，返回integer-reply：member的排名。 如果member不是有序集key的成员，返回bulk-string-reply: nil。 redis-cli 例子1234567891011redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZRANK myzset "three"(integer) 2redis&gt; ZRANK myzset "four"(nil)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrangebyscore]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrangebyscore%2F</url>
    <content type="text"><![CDATA[语法1ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 解释如果M是常量（比如，用limit总是请求前10个元素），你可以认为是O(log(N))。 返回key的有序集合中的分数在min和max之间的所有元素（包括分数等于max或者min的元素）。元素被认为是从低分到高分排序的。 具有相同分数的元素按字典序排列（这个根据redis对有序集合实现的情况而定，并不需要进一步计算）。 可选的LIMIT参数指定返回结果的数量及区间（类似SQL中SELECT LIMIT offset, count）。注意，如果offset太大，定位offset就可能遍历整个有序集合，这会增加O(N)的复杂度。 可选参数WITHSCORES会返回元素和其分数，而不只是元素。这个选项在redis2.0之后的版本都可用。 区间及无限min和max可以是-inf和+inf，这样一来，你就可以在不知道有序集的最低和最高score值的情况下，使用ZRANGEBYSCORE这类命令。 默认情况下，区间的取值使用闭区间(小于等于或大于等于)，你也可以通过给参数前增加(符号来使用可选的开区间(小于或大于)。 举个例子返回所有符合条件1 &lt; score &lt;= 5的成员；1ZRANGEBYSCORE zset (1 5 返回所有符合条件5 &lt; score &lt; 10 的成员。1ZRANGEBYSCORE zset (5 (10 扩展 支持版本: &gt;= 1.0.5 时间复杂度: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)). 返回值: 指定分数范围的元素列表(也可以返回他们的分数)。 redis-cli 例子123456789101112131415161718redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZRANGEBYSCORE myzset -inf +inf1) "one"2) "two"3) "three"redis&gt; ZRANGEBYSCORE myzset 1 21) "one"2) "two"redis&gt; ZRANGEBYSCORE myzset (1 21) "two"redis&gt; ZRANGEBYSCORE myzset (1 (2(empty list or set)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrevrangebylex]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrevrangebylex%2F</url>
    <content type="text"><![CDATA[语法1ZREVRANGEBYLEX key max min [LIMIT offset count] 解释ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行倒序排列时,可以使用Redis中SortSet这种数据结构来处理。 说明 指令 是否必须 说明 key 是 有序集合键名称 max 是 字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替 min 是 字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替 LIMIT 否 返回结果是否分页,指令中包含LIMIT后offset、count必须输入 offset 否 返回结果起始位置 count 否 返回结果数量 提示 分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。 成员字符串作为二进制数组的字节数进行比较。 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。 源码中采用C语言中 memcmp() 函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠前。 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “max”和 “min”“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。 可以使用 “-“ 和 “+” 表示得分最小值和最大值“max”和 “min” 不能反, “max” 放后面 “min”放前面会导致返回结果为空 与ZREVRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX。 扩展 支持版本: &gt;= 2.8.9 时间复杂度: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)). 返回值: 指定成员范围的元素列表。 redis-cli 例子不要在分数不一致的SortSet集合中去使用 ZREVRANGEBYLEX 指令,因为获取的结果并不准确。 获取所有值可以使用 “-“ 和 “+” 表示最小值和最大值123456789101112131415redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; ZREVRANGEBYLEX zset + - 1) "z1" 2) "z" 3) "dobble" 4) "dd" 5) "d1" 6) "d" 7) "c" 8) "b" 9) "apple"10) "abc"11) "aa"12) "a" 获取分页数据12345678redis&gt; ZREVRANGEBYLEX zset + - LIMIT 0 31) "z1"2) "z"3) "dobble"redis&gt; ZREVRANGEBYLEX zset + - LIMIT 3 31) "dd"2) "d1"3) "d" 获取成员之间的元素默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。123456redis&gt; ZREVRANGEBYLEX zset [c [aa1) "c"2) "b"3) "apple"4) "abc"5) "aa" “min” 和 “max” 不能反, “min” 放前面 “max”放后面会导致返回结果为空12redis&gt; ZREVRANGEBYLEX zset [aa [c(empty list or set) 使用 “(“ 小于号获取成员之间的元素“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。12345redis&gt; ZREVRANGEBYLEX zset (c [aa1) "b"2) "apple"3) "abc"4) "aa" ASCII码的影响成员字符串作为二进制数组的字节数进行比较。默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。123456789101112131415161718192021222324redis&gt; zadd zset 0 dB(integer) 1redis&gt; ZREVRANGEBYLEX zset + - 1) "z1" 2) "z" 3) "dobble" 4) "dd" 5) "dB" 6) "d1" 7) "d" 8) "c" 9) "b"10) "apple"11) "abc"12) "aa"13) "a"redis&gt; ZREVRANGEBYLEX zset + - limit 0 31) "z1"2) "z"3) "dobble"redis&gt; ZREVRANGEBYLEX zset + - limit 3 31) "dd"2) "dB"3) "d1" 电话号码排序我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:123456redis&gt; zadd phone 0 13100111100 0 13110114300 0 13132110901 (integer) 3redis&gt; zadd phone 0 13200111100 0 13210414300 0 13252110901 (integer) 3redis&gt; zadd phone 0 13300111100 0 13310414300 0 13352110901 (integer) 3 #####从大到小获取所有号码#####12345678910redis&gt; ZREVRANGEBYLEX phone + -1) "13352110901"2) "13310414300"3) "13300111100"4) "13252110901"5) "13210414300"6) "13200111100"7) "13132110901"8) "13110114300"9) "13100111100" #####获取132号段#####1234redis&gt; ZREVRANGEBYLEX phone (133 [1321) "13252110901"2) "13210414300"3) "13200111100" #####获取132、133号段#####1234567redis&gt; ZREVRANGEBYLEX phone (134 [1321) "13352110901"2) "13310414300"3) "13300111100"4) "13252110901"5) "13210414300"6) "13200111100" 姓名排序将名称存储到SortSet中12redis&gt; zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua (integer) 6 #####获取所有人的名字倒序排列#####1234567redis&gt; ZREVRANGEBYLEX names + -1) "Toumas"2) "Jake"3) "Gaodeng"4) "Bluetuo"5) "Aimini"6) "Aidehua" #####获取名字中大写字母A开头的所有人#####123redis&gt; ZREVRANGEBYLEX names (B [A1) "Aimini"2) "Aidehua" #####获取名字中大写字母C到Z的所有人#####1234redis&gt; ZREVRANGEBYLEX names [Z [C1) "Toumas"2) "Jake"3) "Gaodeng" Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrangebylex]]></title>
    <url>%2Fredis%2F2018%2F05%2F22%2Fzrangebylex%2F</url>
    <content type="text"><![CDATA[语法1ZRANGEBYLEX key min max [LIMIT offset count] 解释ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。 在某些业务场景中,需要对一个字符串数组按名称的字典顺序进行排序时,可以使用Redis中SortSet这种数据结构来处理。 说明 指令 是否必须 说明 key 是 有序集合键名称 min 是 字典中排序位置较小的成员,必须以”[“开头,或者以”(“开头,可使用”-“代替 max 是 字典中排序位置较大的成员,必须以”[“开头,或者以”(“开头,可使用”+”代替 LIMIT 否 返回结果是否分页,指令中包含LIMIT后offset、count必须输入 offset 否 返回结果起始位置 count 否 返回结果数量 提示 分数必须相同! 如果有序集合中的成员分数有不一致的,返回的结果就不准。 成员字符串作为二进制数组的字节数进行比较。 默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。 默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。”[” - 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。 “max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。 可以使用 “-“ 和 “+” 表示得分最小值和最大值 “min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空 与ZRANGEBYLEX获取顺序相反的指令是ZREVRANGEBYLEX。 源码中采用C语言中 memcmp() 函数, 从字符的第0位到最后一位进行排序,如果前面部分相同,那么较长的字符串比较短的字符串排序靠后。扩展 支持版本: &gt;= 2.8.9 时间复杂度: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)). 返回值: 指定成员范围的元素列表。 redis-cli 例子获取所有值可以使用 “-“ 和 “+” 表示得分最小值和最大值123456789101112131415redis&gt; zadd zset 0 a 0 aa 0 abc 0 apple 0 b 0 c 0 d 0 d1 0 dd 0 dobble 0 z 0 z1(integer) 12redis&gt; ZRANGEBYLEX zset - + 1) "a" 2) "aa" 3) "abc" 4) "apple" 5) "b" 6) "c" 7) "d" 8) "d1" 9) "dd"10) "dobble"11) "z"12) "z1" 获取分页数据12345678redis&gt; ZRANGEBYLEX zset - + LIMIT 0 31) "a"2) "aa"3) "abc"redis&gt; ZRANGEBYLEX zset - + LIMIT 3 31) "apple"2) "b"3) "c" 获取成员之间的元素默认情况下, “max” 和 “min” 参数前必须加 “[” 符号作为开头。“[” 符号与成员之间不能有空格, 返回成员结果集会包含参数 “min” 和 “max” 。123456redis&gt; ZRANGEBYLEX zset [aa [c1) "aa"2) "abc"3) "apple"4) "b"5) "c" “min” 和 “max” 不能反, “max” 放前面 “min”放后面会导致返回结果为空12redis&gt; ZRANGEBYLEX zset [c [aa(empty list or set) 使用 “(“ 小于号获取成员之间的元素“max” 和 “min” 参数前可以加 “(“ 符号作为开头表示小于, “(“ 符号与成员之间不能有空格。返回成员结果集不会包含 “max” 和 “min” 成员。12345redis&gt; ZRANGEBYLEX zset [aa (c1) "aa"2) "abc"3) "apple"4) "b" ASCII码的影响成员字符串作为二进制数组的字节数进行比较。默认是以ASCII字符集的顺序进行排列。如果成员字符串包含utf-8这类字符集的内容,就会影响返回结果,所以建议不要使用。1234567891011121314151617181920redis&gt; zadd zset 0 aBc(integer) 1redis&gt; ZRANGEBYLEX zset - + 1) "a" 2) "aBc" 3) "aa" 4) "abc" 5) "apple" 6) "b" 7) "c" 8) "d" 9) "d1"10) "dd"11) "dobble"12) "z"13) "z1"redis&gt; ZRANGEBYLEX zset - + LIMIT 0 31) "a"2) "aBc"3) "aa" 电话号码排序我们可以将电话号码存储到SortSet中,然后根据需要来获取号段:123456redis&gt; zadd phone 0 13100111100 0 13110114300 0 13132110901 (integer) 3redis&gt; zadd phone 0 13200111100 0 13210414300 0 13252110901 (integer) 3redis&gt; zadd phone 0 13300111100 0 13310414300 0 13352110901 (integer) 3 获取所有号码12345678910redis&gt; ZRANGEBYLEX phone - +1) "13100111100"2) "13110114300"3) "13132110901"4) "13200111100"5) "13210414300"6) "13252110901"7) "13300111100"8) "13310414300"9) "13352110901" 获取132号段1234redis&gt; ZRANGEBYLEX phone [132 (1331) "13200111100"2) "13210414300"3) "13252110901" 1234567redis&gt; ZRANGEBYLEX phone [132 (1341) "13200111100"2) "13210414300"3) "13252110901"4) "13300111100"5) "13310414300"6) "13352110901" 姓名排序将名称存储到SortSet中:12redis&gt; zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua (integer) 6 获取所有人的名字:1234567redis&gt; ZRANGEBYLEX names - +1) "Aidehua"2) "Aimini"3) "Bluetuo"4) "Gaodeng"5) "Jake"6) "Toumas" 获取名字中大写字母A开头的所有人:123redis&gt; ZRANGEBYLEX names [A (B1) "Aidehua"2) "Aimini" 获取名字中大写字母C到Z的所有人:1234redis&gt; ZRANGEBYLEX names [C [Z1) "Gaodeng"2) "Jake"3) "Toumas" Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrange]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzrange%2F</url>
    <content type="text"><![CDATA[语法1ZRANGE key start stop [WITHSCORES] 解释扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned. 返回值: 指定范围内的元素列表（如果WITHSCORES给出选项，可以选择其分数）。 redis-cli 例子12345678910111213141516redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZRANGE myzset 0 -11) "one"2) "two"3) "three"redis&gt; ZRANGE myzset 2 31) "three"redis&gt; ZRANGE myzset -2 -11) "two"2) "three"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zlexcount]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzlexcount%2F</url>
    <content type="text"><![CDATA[语法1ZLEXCOUNT key min max 解释当排序集中的所有元素都以相同分数插入时，为了强制执行词典排序，此命令返回排序集中元素的数量，key其值介于min和之间max。 该min和max参数具有作为描述的意思相同 ZRANGEBYLEX。 注意：该命令的复杂度仅为O（log（N）），因为它使用元素排名（请参阅ZRANK）来了解范围。正因为如此，没有必要做一个与范围的大小成正比的工作。 提示 成员名称前需要加 [ 符号作为开头, [ 符号与成员之间不能有空格 可以使用 - 和 + 表示得分最小值和最大值 min 和 max 不能反, max 放前面 min放后面会导致返回结果为0 计算成员之间的成员数量时,参数 min 和 max 的位置也计算在内。 min 和 max 参数的含义与 zrangebylex 命令中所描述的相同 扩展 支持版本: &gt;= 2.8.9 时间复杂度: O(log(N)) with N being the number of elements in the sorted set. 返回值: 有序集合中成员名称 min 和 max 之间的成员数量 redis-cli 例子计算成员之间成员数量123456789redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e(integer) 5redis&gt; ZADD myzset 0 f 0 g(integer) 2redis&gt; ZLEXCOUNT myzset - +(integer) 7redis&gt; ZLEXCOUNT myzset [b [f(integer) 5redis&gt; 计算某个成员之前或者之后的成员数量表示得分最小值的成员 + 表示得分最大值的成员1234567891011121314151617redis&gt; ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g(integer) 7redis&gt; zrange myzset 0 -11) "a"2) "b"3) "c"4) "d"5) "e"6) "f"7) "g"redis&gt; ZLEXCOUNT myzset - +(integer) 7redis&gt; ZLEXCOUNT myzset [c +(integer) 5redis&gt; ZLEXCOUNT myzset - [c(integer) 3redis&gt; 分数值位置的重要性1234567891011121314151617redis&gt; del myzset(integer) 1redis&gt; ZADD myzset 1 a 2 b 3 c 4 d 5 e 6 f 7 g(integer) 7redis&gt; zrange myzset 0 -11) "a"2) "b"3) "c"4) "d"5) "e"6) "f"7) "g"redis&gt; ZLEXCOUNT myzset [c [f(integer) 4redis&gt; ZLEXCOUNT myzset [f [c(integer) 0redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zinterstore]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzinterstore%2F</url>
    <content type="text"><![CDATA[语法1ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] 解释计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 默认情况下，结果中一个元素的分数是有序集合中该元素分数之和，前提是该元素在这些有序集合中都存在。因为交集要求其成员必须是给定的每个有序集合中的成员，结果集中的每个元素的分数和输入的有序集合个数相等。 对于WEIGHTS和AGGREGATE参数的描述，参见命令ZUNIONSTORE。 如果destination存在，就把它覆盖。 扩展 支持版本: &gt;= 2.0.0 时间复杂度:O(NK)+O(Mlog(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set. 返回值: 结果有序集合destination中元素个数。 redis-cli 例子123456789101112131415161718redis&gt; ZADD zset1 1 "one"(integer) 1redis&gt; ZADD zset1 2 "two"(integer) 1redis&gt; ZADD zset2 1 "one"(integer) 1redis&gt; ZADD zset2 2 "two"(integer) 1redis&gt; ZADD zset2 3 "three"(integer) 1redis&gt; ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3(integer) 2redis&gt; ZRANGE out 0 -1 WITHSCORES1) "one"2) "5"3) "two"4) "10"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zincrby]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzincrby%2F</url>
    <content type="text"><![CDATA[语法1ZINCRBY key increment member 解释为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合。 当key不是有序集类型时，返回一个错误。 score值必须是字符串表示的整数值或双精度浮点数，并且能接受double精度的浮点数。也有可能给一个负数来减少score的值。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(log(N)) where N is the number of elements in the sorted set. 返回值: member成员的新score值，以字符串形式表示。 redis-cli 例子123456789101112redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZINCRBY myzset 2 "one""3"redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) "two"2) "2"3) "one"4) "3"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zcount]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzcount%2F</url>
    <content type="text"><![CDATA[语法1ZCOUNT key min max 解释返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员。 关于参数min和max的详细使用方法，请参考ZRANGEBYSCORE命令 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(log(N)) with N being the number of elements in the sorted set. 返回值: 指定分数范围的元素个数。 redis-cli 例子1234567891011redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZADD myzset 3 "three"(integer) 1redis&gt; ZCOUNT myzset -inf +inf(integer) 3redis&gt; ZCOUNT myzset (1 3(integer) 2redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zcard]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzcard%2F</url>
    <content type="text"><![CDATA[语法1ZCARD key 解释返回key的有序集元素个数。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(1) 返回值: key存在的时候，返回有序集的元素个数，否则返回0。 redis-cli 例子1234567redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 2 "two"(integer) 1redis&gt; ZCARD myzset(integer) 2redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zadd]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fzadd%2F</url>
    <content type="text"><![CDATA[语法1ZADD key [NX|XX] [CH] [INCR] score member [score member ...] 解释将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。 如果key不存在，将会创建一个新的有序集合（sorted set）并将分数/成员（score/member）对添加到有序集合，就像原来存在一个空的有序集合一样。如果key存在，但是类型不是有序集合，将会返回一个错误应答。 分数值是一个双精度的浮点型数字字符串。+inf和-inf都是有效值。 ZADD 参数（options） (&gt;= Redis 3.0.2)ZADD 命令在key后面分数/成员（score/member）对前面支持一些参数，他们是： XX: 仅仅更新存在的成员，不添加新成员。 NX: 不更新存在的成员。只添加新成员。 CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 changed 的意思)。更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，ZADD返回值只计算新添加成员的数量。 INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。 分数可以精确的表示的整数的范围Redis 有序集合的分数使用双精度64位浮点数。我们支持所有的架构，这表示为一个IEEE 754 floating point number，它能包括的整数范围是-(2^53) 到 +(2^53)。或者说是-9007199254740992 到 9007199254740992。更大的整数在内部用指数形式表示，所以，如果为分数设置一个非常大的整数，你得到的是一个近似的十进制数。 Sorted sets 101有序集合按照分数以递增的方式进行排序。相同的成员（member）只存在一次，有序集合不允许存在重复的成员。 分数可以通过ZADD命令进行更新或者也可以通过ZINCRBY命令递增来修改之前的值，相应的他们的排序位置也会随着分数变化而改变。 获取一个成员当前的分数可以使用ZSCORE命令，也可以用它来验证成员是否存在。 相同分数的成员有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能有相同的分数。当多个成员有相同的分数时，他们将是有序的字典（ordered lexicographically）（仍由分数作为第一排序条件，然后，相同分数的成员按照字典规则相对排序）。 字典顺序排序用的是二进制，它比较的是字符串的字节数组。 如果用户将所有元素设置相同分数（例如0），有序集合里面的所有元素将按照字典顺序进行排序，范围查询元素可以使用ZRANGEBYLEX命令（注：范围查询分数可以使用ZRANGEBYSCORE命令）。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(log(N)) for each item added, where N is the number of elements in the sorted set. 返回值: 包括: 添加到有序集合的成员数量，不包括已经存在更新分数的成员。 如果指定INCR参数, 返回将会变成bulk-string-reply 成员的新分数（双精度的浮点型数字）字符串。 历史： 在Redis 2.4以前，命令只能添加或者更新一个成员。 redis-cli 例子12345678910111213141516redis&gt; ZADD myzset 1 "one"(integer) 1redis&gt; ZADD myzset 1 "uno"(integer) 1redis&gt; ZADD myzset 2 "two" 3 "three"(integer) 2redis&gt; ZRANGE myzset 0 -1 WITHSCORES1) "one"2) "1"3) "uno"4) "1"5) "two"6) "2"7) "three"8) "3"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>zset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sunionstore]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsunionstore%2F</url>
    <content type="text"><![CDATA[语法1SUNIONSTORE destination key [key ...] 解释该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中. 如果destination 已经存在,则将其覆盖. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the total number of elements in all given sets. 返回值: 结果集中元素的个数. redis-cli 例子123456789101112131415161718192021redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SUNIONSTORE key key1 key2(integer) 5redis&gt; SMEMBERS key1) "c"2) "e"3) "b"4) "a"5) "d"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sunion]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsunion%2F</url>
    <content type="text"><![CDATA[语法1SUNION key [key ...] 解释返回给定的多个集合的并集中的所有成员.例如:1234key1 = &#123;a,b,c,d&#125;key2 = &#123;c&#125;key3 = &#123;a,c,e&#125;SUNION key1 key2 key3 = &#123;a,b,c,d,e&#125; 不存在的key可以认为是空的集合. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the total number of elements in all given sets. 返回值: 并集的成员列表 redis-cli 例子12345678910111213141516171819redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SUNION key1 key21) "a"2) "b"3) "c"4) "d"5) "e"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sscan]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsscan%2F</url>
    <content type="text"><![CDATA[语法1SSCAN key cursor [MATCH pattern] [COUNT count] 解释SSCAN是一个迭代器，可以返回一个SET里面所有的元素跟keys类似，不过并非一次性全部返回，而是返回部分当SSCAN命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。 扩展 支持版本: &gt;= 2.8.0 时间复杂度: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.. 返回值: 命令返回的每个元素都是一个集合成员。 redis-cli 例子12345678redis&gt; sadd myset 1 2 3 foo foobar feelsgood(integer) 6redis&gt; sscan myset 0 match f*1) "0"2) 1) "foo" 2) "feelsgood" 3) "foobar"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[srem]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsrem%2F</url>
    <content type="text"><![CDATA[语法1SREM key member [member ...] 解释在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0. 如果key的类型不是一个集合,则返回错误. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the number of members to be removed. 返回值: 从集合中移除元素的个数，不包括不存在的成员. 历史： 2.4之前的版本每次只能移除一个元素. redis-cli 例子1234567891011121314redis&gt; SADD myset "one"(integer) 1redis&gt; SADD myset "two"(integer) 1redis&gt; SADD myset "three"(integer) 1redis&gt; SREM myset "one"(integer) 1redis&gt; SREM myset "four"(integer) 0redis&gt; SMEMBERS myset1) "three"2) "two"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[srandmember]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsrandmember%2F</url>
    <content type="text"><![CDATA[语法1SRANDMEMBER key [count] 解释仅提供key参数,那么随机返回key集合中的一个元素. Redis 2.6开始, 可以接受 count 参数,如果count是整数且小于元素的个数，返回含有 count 个不同的元素的数组,如果count是个整数且大于集合中元素的个数时,仅返回整个集合的所有元素,当count是负数,则会返回一个包含count的绝对值的个数元素的数组，如果count的绝对值大于元素的个数,则返回的结果集里会出现一个元素出现多次的情况. 仅提供key参数时,该命令作用类似于SPOP命令, 不同的是SPOP命令会将被选择的随机元素从集合中移除, 而SRANDMEMBER仅仅是返回该随记元素,而不做任何操作. 扩展 支持版本: &gt;= 1.0.0 时间复杂度:Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count. 返回值: 不使用count 参数的情况下该命令返回随机的元素,如果key不存在则返回nil. 使用count参数,则返回一个随机的元素数组,如果key不存在则返回一个空的数组. redis-cli 例子1234567891011121314redis&gt; SADD myset one two three(integer) 3redis&gt; SRANDMEMBER myset"one"redis&gt; SRANDMEMBER myset 21) "three"2) "one"redis&gt; SRANDMEMBER myset -51) "one"2) "one"3) "one"4) "one"5) "one"redis&gt; Spring Boot例子12 有COUNT时的行为规范当一个count参数被传递，这些元素被返回，就好像每个被选中的元素都被从集合中移除一样（比如提取宾果游戏中的数字）。但是元素不会从Set中删除。所以基本上： 没有重复的元素被返回。 如果count大于Set内部的元素数量，该命令将仅返回整个集合而不包含其他元素。如果计数是负数，则行为会发生变化，并且提取会发生，就好像在每次提取后再次将提取的元素放入包中一样，因此可能会重复元素，并且总是会返回请求的元素数量，因为我们可以重复相同的元素元素一次又一次，除了一个空的Set（不存在的键），它总是会产生一个空数组。 返回元素的分配当集合中的元素数量很少时，返回元素的分布还远未完善，这是因为我们使用了一个近似的随机元素函数，并不能真正保证良好的分布。 使用的算法在dict.c中实现，对哈希表桶进行采样以找到非空的桶。一旦找到一个非空的桶，因为我们在我们的哈希表实现中使用链接，所以会检查桶内的元素数量并选择一个随机元素。 这意味着如果在整个散列表中有两个非空桶，并且一个有三个元素，而另一个只有一个，那么在桶中单独存在的元素将返回的概率要高得多。]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spop]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fspop%2F</url>
    <content type="text"><![CDATA[语法1SPOP key [count] 解释从SET里随机删除并返回count个元素 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O（1） 返回值: 被删除的元素，或者nil当key不存在。 历史: count参数需要版本&gt;=3.2的时候才可用 其他时候只能弹出一个元素 redis-cli 例子12345678910111213141516171819202122redis&gt; SADD myset "one"(integer) 1redis&gt; SADD myset "two"(integer) 1redis&gt; SADD myset "three"(integer) 1redis&gt; SPOP myset"two"redis&gt; SMEMBERS myset1) "three"2) "one"redis&gt; SADD myset "four"(integer) 1redis&gt; SADD myset "five"(integer) 1redis&gt; SPOP myset 31) "three"2) "one"3) "four"redis&gt; SMEMBERS myset1) "five"redis&gt; Spring Boot例子12 COUNT超出时如果count大于Set内部的元素数量，该命令将仅返回整个集合而不包含其他元素。 返回元素的分配请注意，当您需要保证返回元素的均匀分布时，此命令不适用。有关用于SPOP的算法的更多信息，请查找Knuth采样和Floyd采样算法。]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smove]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsmove%2F</url>
    <content type="text"><![CDATA[语法1SMOVE source destination member 解释将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现. 如果source 集合不存在或者不包含指定的元素,这smove命令不执行任何操作并且返回0.否则对象将会从source集合中移除，并添加到destination集合中去，如果destination集合已经存在该元素，则smove命令仅将该元素充source集合中移除. 如果source 和destination不是集合类型,则返回错误. 扩展 支持版本: &gt;= 时间复杂度: 返回值: 如果该元素成功移除,返回1 如果该元素不是 source集合成员,无任何操作,则返回0. redis-cli 例子1234567891011121314redis&gt; SADD myset "one"(integer) 1redis&gt; SADD myset "two"(integer) 1redis&gt; SADD myotherset "three"(integer) 1redis&gt; SMOVE myset myotherset "two"(integer) 1redis&gt; SMEMBERS myset1) "one"redis&gt; SMEMBERS myotherset1) "three"2) "two"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smembers]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsmembers%2F</url>
    <content type="text"><![CDATA[语法1SMEMBERS key 解释返回key集合所有的元素. 该命令的作用与使用一个参数的SINTER 命令作用相同. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the set cardinality. 返回值: 集合中的所有元素. redis-cli 例子12345678redis&gt; SADD myset "Hello"(integer) 1redis&gt; SADD myset "World"(integer) 1redis&gt; SMEMBERS myset1) "World"2) "Hello"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sismember]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsismember%2F</url>
    <content type="text"><![CDATA[语法1SISMEMBER key member 解释返回成员 member 是否是存储的集合 key的成员. 扩展 支持版本: &gt;= 时间复杂度: 返回值: 详细说明: 如果member元素是集合key的成员，则返回1 如果member元素不是key的成员，或者集合key不存在，则返回0 redis-cli 例子1234567redis&gt; SADD myset "one"(integer) 1redis&gt; SISMEMBER myset "one"(integer) 1redis&gt; SISMEMBER myset "two"(integer) 0redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sinterstore]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsinterstore%2F</url>
    <content type="text"><![CDATA[语法1SINTERSTORE destination key [key ...] 解释这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中. 如果destination 集合存在, 则会被覆盖 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets. 返回值: 结果集中成员的个数. redis-cli 例子1234567891011121314151617redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SINTERSTORE key key1 key2(integer) 1redis&gt; SMEMBERS key1) "c"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sinter]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsinter%2F</url>
    <content type="text"><![CDATA[语法1SINTER key [key ...] 解释返回指定所有的集合的成员的交集.例如:1234key1 = &#123;a,b,c,d&#125;key2 = &#123;c&#125;key3 = &#123;a,c,e&#125;SINTER key1 key2 key3 = &#123;c&#125; 如果key不存在则被认为是一个空的集合,当给定的集合为空的时候,结果也为空.(一个集合为空，结果一直为空). 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets. 返回值: 结果集成员的列表 redis-cli 例子123456789101112131415redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SINTER key1 key21) "c"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sdiffstore]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsdiffstore%2F</url>
    <content type="text"><![CDATA[语法1SDIFFSTORE destination key [key ...] 解释该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中. 如果destination已经存在, 则将其覆盖重写. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the total number of elements in all given sets. 返回值: 结果集元素的个数. redis-cli 例子123456789101112131415161718redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SDIFFSTORE key key1 key2(integer) 2redis&gt; SMEMBERS key1) "b"2) "a"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sdiff]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsdiff%2F</url>
    <content type="text"><![CDATA[语法1SDIFF key [key ...] 解释返回的集合元素是第一个key的集合与后面所有key的集合的差集举例:1234key1 = &#123;a,b,c,d&#125;key2 = &#123;c&#125;key3 = &#123;a,c,e&#125;SDIFF key1 key2 key3 = &#123;b,d&#125; 不存在的key认为是空集. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the total number of elements in all given sets. 返回值: 结果集的元素. redis-cli 例子12345678910111213141516redis&gt; SADD key1 "a"(integer) 1redis&gt; SADD key1 "b"(integer) 1redis&gt; SADD key1 "c"(integer) 1redis&gt; SADD key2 "c"(integer) 1redis&gt; SADD key2 "d"(integer) 1redis&gt; SADD key2 "e"(integer) 1redis&gt; SDIFF key1 key21) "a"2) "b"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scard]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fscard%2F</url>
    <content type="text"><![CDATA[语法1SCARD key 解释返回集合存储的key的基数 (集合元素的数量). 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 集合的基数(元素的数量),如果key不存在,则返回 0. redis-cli 例子1234567redis&gt; SADD myset "Hello"(integer) 1redis&gt; SADD myset "World"(integer) 1redis&gt; SCARD myset(integer) 2redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sadd]]></title>
    <url>%2Fredis%2F2018%2F05%2F18%2Fsadd%2F</url>
    <content type="text"><![CDATA[语法1SADD key member [member ...] 解释添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中. 如果key 的类型不是集合则返回错误. 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the number of members to be added. 返回值: 返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素. 历史：Redis 2.4 以前的版本每次只能添加一个member元素. redis-cli 例子12345678910redis&gt; SADD myset "Hello"(integer) 1redis&gt; SADD myset "World"(integer) 1redis&gt; SADD myset "World"(integer) 0redis&gt; SMEMBERS myset1) "World"2) "Hello"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hscan]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhscan%2F</url>
    <content type="text"><![CDATA[语法1HSCAN key cursor [MATCH pattern] [COUNT count] 解释HSCAN是一个迭代器，可以返回一个hashs里面所有的key跟keys类似，不过并非一次性全部返回，而是返回部分当HSCAN命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。 扩展 支持版本: &gt;= 2.8.0 时间复杂度: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.. 返回值: HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。 redis-cli 例子12345678redis&gt; hmset hash name Jack age 33OKredis&gt; hscan hash 01) "0"2) 1) "name" 2) "Jack" 3) "age" 4) "33" 在上面这个例子中， 第一次迭代使用 0 作为游标， 表示开始一次新的迭代。第二次迭代使用的是第一次迭代时返回的游标 17 ，作为新的迭代参数 。 显而易见，HSCAN命令的返回值 是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。 在第二次调用 HSCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集已经被完整遍历过了。 full iteration ：以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。 Spring Boot例子12 HSCAN命令每次执行返回的元素数量HSCAN增量式迭代命令并不保证每次执行都返回某个给定数量的元素,甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。 不过命令返回的元素数量总是符合一定规则的， 对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（小的sets, hashes and sorted sets）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。 如果需要的话，用户可以通过增量式迭代命令提供的COUNT选项来指定每次迭代返回元素的最大值。 COUNT选项对于增量式迭代命令不保证每次迭代所返回的元素数量，我们可以使用COUNT选项， 对命令的行为进行一定程度上的调整。COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。使用COUNT 选项对于对增量式迭代命令相当于一种提示， 大多数情况下这种提示都比较有效的控制了返回值的数量。 COUNT 参数的默认值为 10 。 数据集比较大时，如果没有使用MATCH 选项, 那么命令返回的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。 在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给用户。注意: 并非每次迭代都要使用相同的 COUNT 值 ，用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。 MATCH 选项类似于KEYS 命令，增量式迭代命令通过给定 MATCH 参数的方式实现了通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素。 以下是一个使用 MATCH 选项进行迭代的示例:1234567891011redis&gt; HMSET hashKey f1 &quot;v1&quot; f2 &quot;v2&quot; f3 &quot;v3&quot; x4 &quot;v4&quot;OKredis&gt; HSACN hashKey 0 match f*1) &quot;0&quot;2) 1) &quot;f1&quot; 2) &quot;v1&quot; 3) &quot;f2&quot; 4) &quot;v2&quot; 5) &quot;f3&quot; 6) &quot;v3&quot;redis&gt; MATCH功能对元素的模式匹配工作是在命令从数据集中取出元素后和向客户端返回元素前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。 并发执行多个迭代在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。 中止迭代因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。即使有任意数量的迭代在中途停止， 也不会产生任何问题。 使用错误的游标使用SCAN 命令传入间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。 只有两种游标是合法的: 在开始一个新的迭代时， 游标必须为 0 。 增量式迭代命令在执行之后返回的， 用于延续迭代过程的游标。 迭代能终止的前提增量式迭代命令所使用的算法只保证在数据集的大小有界的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。 从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hmset]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhmset%2F</url>
    <content type="text"><![CDATA[语法1HMSET key field value [field value ...] 解释设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(N) where N is the number of fields being set. 返回值: OK redis-cli 例子1234567redis&gt; HMSET myhash field1 "Hello" field2 "World"OKredis&gt; HGET myhash field1"Hello"redis&gt; HGET myhash field2"World"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhmget%2F</url>
    <content type="text"><![CDATA[title: hmgetdate: 2018-05-17 14:31:06 tags: hash语法1HMGET key field [field ...] 解释返回 key 指定的哈希集中指定字段的值。 对于哈希集中不存在的每个字段，返回 nil 值。因为不存在的keys被认为是一个空的哈希集，对一个不存在的 key 执行 HMGET 将返回一个只含有 nil 值的列表 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(N) where N is the number of fields being requested. 返回值: 含有给定字段及其值的列表，并保持与请求相同的顺序。 redis-cli 例子123456789redis&gt; HSET myhash field1 "Hello"(integer) 1redis&gt; HSET myhash field2 "World"(integer) 1redis&gt; HMGET myhash field1 field2 nofield1) "Hello"2) "World"3) (nil)redis&gt; Spring Boot例子12]]></content>
  </entry>
  <entry>
    <title><![CDATA[hlen]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhlen%2F</url>
    <content type="text"><![CDATA[语法1HLEN key 解释返回 key 指定的哈希集包含的字段的数量。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0 redis-cli 例子1234567redis&gt; HSET myhash field1 "Hello"(integer) 1redis&gt; HSET myhash field2 "World"(integer) 1redis&gt; HLEN myhash(integer) 2redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hkeys]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhkeys%2F</url>
    <content type="text"><![CDATA[语法1HKEYS key 解释返回 key 指定的哈希集中所有字段的名字。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(N) where N is the size of the hash. 返回值: 哈希集中的字段列表，当 key 指定的哈希集不存在时返回空列表。 redis-cli 例子12345678redis&gt; HSET myhash field1 "Hello"(integer) 1redis&gt; HSET myhash field2 "World"(integer) 1redis&gt; HKEYS myhash1) "field1"2) "field2"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hincrbyfloat]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhincrbyfloat%2F</url>
    <content type="text"><![CDATA[语法1HINCRBYFLOAT key field increment 解释为指定key的hash的field字段值执行float类型的increment加。如果field不存在，则在执行该操作前设置为0.如果出现下列情况之一，则返回错误： field的值包含的类型错误(不是字符串)。 当前field或者increment不能解析为一个float类型。此命令的确切行为与INCRBYFLOAT命令相同，请参阅INCRBYFLOAT命令获取更多信息。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: field执行increment加后的值 redis-cli 例子123456789redis&gt; HSET mykey field 10.50(integer) 1redis&gt; HINCRBYFLOAT mykey field 0.1"10.6"redis&gt; HSET mykey field 5.0e3(integer) 0redis&gt; HINCRBYFLOAT mykey field 2.0e2"5200"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hincrby]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhincrby%2F</url>
    <content type="text"><![CDATA[语法1HINCRBY key field increment 解释增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0 HINCRBY 支持的值的范围限定在 64位 有符号整数 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 增值操作执行后的该字段的值。 redis-cli 例子123456789redis&gt; HSET myhash field 5(integer) 1redis&gt; HINCRBY myhash field 1(integer) 6redis&gt; HINCRBY myhash field -1(integer) 5redis&gt; HINCRBY myhash field -10(integer) -5redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hgetall]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhgetall%2F</url>
    <content type="text"><![CDATA[语法1HGETALL key 解释返回 key 指定的哈希集中所有的字段和值。返回值中，每个字段名的下一个是它的值，所以返回值的长度是哈希集大小的两倍 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(N) where N is the size of the hash. 返回值: 哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。 redis-cli 例子12345678910redis&gt; HSET myhash field1 "Hello"(integer) 1redis&gt; HSET myhash field2 "World"(integer) 1redis&gt; HGETALL myhash1) "field1"2) "Hello"3) "field2"4) "World"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdel]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhdel%2F</url>
    <content type="text"><![CDATA[语法1HDEL key field [field ...] 解释从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。 如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(N) N是被删除的字段数量。 返回值: 返回从哈希集中成功移除的域的数量，不包括指出但不存在的那些域 历史: 小于 2.4版本 的 Redis 每次调用只能移除一个域 要在早期版本中以原子方式从哈希集中移除多个域，可用 MULTI/EXEC块。 redis-cli 例子1234567redis&gt; HSET myhash field1 "foo"(integer) 1redis&gt; HDEL myhash field1(integer) 1redis&gt; HDEL myhash field2(integer) 0redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexists]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhexists%2F</url>
    <content type="text"><![CDATA[语法1HEXISTS key field 解释返回hash里面field是否存在 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 含义如下： 1 hash里面包含该field。 0 hash里面不包含该field或者key不存在。 redis-cli 例子1234567redis&gt; HSET myhash field1 "foo"(integer) 1redis&gt; HEXISTS myhash field1(integer) 1redis&gt; HEXISTS myhash field2(integer) 0redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hget]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhget%2F</url>
    <content type="text"><![CDATA[语法1HGET key field 解释返回 key 指定的哈希集中该字段所关联的值 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 该字段所关联的值。当字段不存在或者 key 不存在时返回nil。 redis-cli 例子1234567redis&gt; HSET myhash field1 "foo"(integer) 1redis&gt; HGET myhash field1"foo"redis&gt; HGET myhash field2(nil)redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hset]]></title>
    <url>%2Fredis%2F2018%2F05%2F17%2Fhset%2F</url>
    <content type="text"><![CDATA[语法1HSET key field value 解释设置 key 指定的哈希集中指定字段的值。 如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。 如果字段在哈希集中存在，它将被重写。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 含义如下 1如果field是一个新的字段 0如果field原来在map里面已经存在 redis-cli 例子12345redis&gt; HSET myhash field1 "Hello"(integer) 1redis&gt; HGET myhash field1"Hello"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpushx]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Frpushx%2F</url>
    <content type="text"><![CDATA[语法1RPUSHX key value 解释将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: RPUSHX 命令执行之后，表的长度。 redis-cli 例子123456789101112redis&gt; RPUSH mylist "Hello"(integer) 1redis&gt; RPUSHX mylist "World"(integer) 2redis&gt; RPUSHX myotherlist "World"(integer) 0redis&gt; LRANGE mylist 0 -11) "Hello"2) "World"redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("key存在时") void keyExistTest() &#123; String randomListKey = getRandomList(10); try &#123; String pushValue = UUID.randomUUID().toString(); Long pushResult = stringRedisTemplate.opsForList().rightPushIfPresent(randomListKey, pushValue); logger.info("RPUSH &#123;&#125; &#123;&#125; &gt; &#123;&#125;", randomListKey, pushResult, pushResult); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("keyExistTest,rangeResult &gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; @Test @DisplayName("key不存在时") void keyNotExistTest() &#123; String randomListKey = getRandomList(0); try &#123; String pushValue = UUID.randomUUID().toString(); Long pushResult = stringRedisTemplate.opsForList().rightPushIfPresent(randomListKey, pushValue); logger.info("RPUSH &#123;&#125; &#123;&#125; &gt; &#123;&#125;", randomListKey, pushResult, pushResult); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("keyNotExistTest,rangeResult &gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; /** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */ private String getRandomList(int eleCount) &#123; String listTestKey = String.format("rpushx:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpush]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Frpush%2F</url>
    <content type="text"><![CDATA[语法1RPUSH key value [value ...] 解释向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。 可以使用一个命令把多个元素打入队列，只需要在命令后面指定多个参数。元素是从左到右一个接一个从列表尾部插入。 比如命令 RPUSH mylist a b c 会返回一个列表，其第一个元素是 a ，第二个元素是 b ，第三个元素是 c。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: 1.0.0 返回值: 在 push 操作后的列表长度。 历史： 在老于 2.4 的 Redis 版本中，一条命令只能 push 单一个值。 redis-cli 例子12345678redis&gt; RPUSH mylist "hello"(integer) 1redis&gt; RPUSH mylist "world"(integer) 2redis&gt; LRANGE mylist 0 -11) "hello"2) "world"redis&gt; Spring Boot例子12345678910111213141516171819202122private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("默认测试") void genericTest() &#123; String listTestKey = String.format("rpush:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); try &#123; stringRedisTemplate.opsForList().rightPush(listTestKey, "1"); logger.info("RPUSH &#123;&#125; 1", listTestKey); stringRedisTemplate.opsForList().rightPush(listTestKey, "2"); logger.info("RPUSH &#123;&#125; 2", listTestKey); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(listTestKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("rangeResult &gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(listTestKey); &#125; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpoplpush]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Frpoplpush%2F</url>
    <content type="text"><![CDATA[语法1RPOPLPUSH source destination 解释原子性地返回并移除存储在 source 的列表的最后一个元素（列表尾部元素）， 并把该元素放入存储在 destination 的列表的第一个元素位置（列表头部）。 例如：假设 source 存储着列表 a,b,c， destination存储着列表 x,y,z。 执行 RPOPLPUSH 得到的结果是 source 保存着列表 a,b ，而 destination 保存着列表 c,x,y,z。 如果 source 不存在，那么会返回 nil 值，并且不会执行任何操作。 如果 source 和 destination 是同样的，那么这个操作等同于移除列表最后一个元素并且把该元素放在列表头部， 所以这个命令也可以当作是一个旋转列表的命令。 扩展 支持版本: &gt;= 1.2.0 时间复杂度: O(1) 返回值: 被移除和放入的元素 redis-cli 例子1234567891011121314redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; RPOPLPUSH mylist myotherlist"three"redis&gt; LRANGE mylist 0 -11) "one"2) "two"redis&gt; LRANGE myotherlist 0 -11) "three"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; // source从尾部弹出一个元素，然后存入destination头部 stringRedisTemplate.opsForList().rightPopAndLeftPush(randomListKey,randomListKey); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("rangeResult &gt; &#123;&#125;",s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("rpoplpush:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125; 模式：安全的队列Redis通常都被用做一个处理各种后台工作或消息任务的消息服务器。 一个简单的队列模式就是：生产者把消息放入一个列表中，等待消息的消费者用 RPOP 命令（用轮询方式）， 或者用 BRPOP 命令（如果客户端使用阻塞操作会更好）来得到这个消息。 然而，因为消息有可能会丢失，所以这种队列并是不安全的。例如，当接收到消息后，出现了网络问题或者消费者端崩溃了， 那么这个消息就丢失了。 RPOPLPUSH (或者其阻塞版本的 BRPOPLPUSH） 提供了一种方法来避免这个问题：消费者端取到消息的同时把该消息放入一个正在处理中的列表。 当消息被处理了之后，该命令会使用 LREM 命令来移除正在处理中列表中的对应消息。 另外，可以添加一个客户端来监控这个正在处理中列表，如果有某些消息已经在这个列表中存在很长时间了（即超过一定的处理时限）， 那么这个客户端会把这些超时消息重新加入到队列中。 模式：循环列表RPOPLPUSH 命令的 source 和 destination 是相同的话， 那么客户端在访问一个拥有n个元素的列表时，可以在 O(N) 时间里一个接一个获取列表元素， 而不用像 LRANGE 那样需要把整个列表从服务器端传送到客户端。 上面这种模式即使在以下两种情况下照样能很好地工作： 有多个客户端同时对同一个列表进行旋转（rotating）：它们会取得不同的元素，直到列表里所有元素都被访问过，又从头开始这个操作。 有其他客户端在往列表末端加入新的元素。 这个模式让我们可以很容易地实现这样一个系统：有 N 个客户端，需要连续不断地对一批元素进行处理，而且处理的过程必须尽可能地快。 一个典型的例子就是服务器上的监控程序：它们需要在尽可能短的时间内，并行地检查一批网站，确保它们的可访问性。 值得注意的是，使用这个模式的客户端是易于扩展（scalable）且安全的（reliable），因为即使客户端把接收到的消息丢失了， 这个消息依然存在于队列中，等下次迭代到它的时候，由其他客户端进行处理。]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpop]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Frpop%2F</url>
    <content type="text"><![CDATA[语法1RPOP key 解释移除并返回存于 key 的 list 的最后一个元素。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 最后一个元素的值，或者当 key 不存在的时候返回 nil。 redis-cli 例子123456789101112redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; RPOP mylist"three"redis&gt; LRANGE mylist 0 -11) "one"2) "two"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; String popResult = stringRedisTemplate.opsForList().rightPop(randomListKey); logger.info("RPOP &#123;&#125; &gt; &#123;&#125;", randomListKey, popResult); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("rangeResult -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("rpop:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ltrim]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fltrim%2F</url>
    <content type="text"><![CDATA[语法1LTRIM key start stop 解释修剪(trim)一个已存在的 list，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。 例如： LTRIM foobar 0 2 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。 start 和 end 也可以用负数来表示与表尾的偏移量，比如 -1 表示列表里的最后一个元素， -2 表示倒数第二个，等等。 超过范围的下标并不会产生错误：如果 start 超过列表尾部，或者 start &gt; end，结果会是列表变成空表（即该 key 会被移除）。 如果 end 超过列表尾部，Redis 会将其当作列表的最后一个元素。 LTRIM 的一个常见用法是和 LPUSH / RPUSH 一起使用。 例如： LPUSH mylist someelement LTRIM mylist 0 99 这一对命令会将一个新的元素 push 进列表里，并保证该列表不会增长到超过100个元素。这个是很有用的，比如当用 Redis 来存储日志。 需要特别注意的是，当用这种方式来使用 LTRIM 的时候，操作的复杂度是 O(1) ， 因为平均情况下，每次只有一个元素会被移除。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the number of elements to be removed by the operation. 返回值: OK redis-cli 例子123456789101112redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; LTRIM mylist 1 -1OKredis&gt; LRANGE mylist 0 -11) "two"2) "three"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("默认测试") void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; // 只留下列表里面下标范围为0到5 的元素 stringRedisTemplate.opsForList().trim(randomListKey, 0, 5); logger.info("LTRIM &#123;&#125; 0 5", randomListKey); // 获取全部元素 List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("rangeResult &gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; /** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */ private String getRandomList(int eleCount) &#123; String listTestKey = String.format("ltrim:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lset]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flset%2F</url>
    <content type="text"><![CDATA[语法1LSET key index value 解释设置 index 位置的list元素的值为 value。 更多关于 index 参数的信息，详见 LINDEX。 当index超出范围时会返回一个error。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1). 返回值: OK redis-cli 例子123456789101112131415redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; LSET mylist 0 "four"OKredis&gt; LSET mylist -2 "five"OKredis&gt; LRANGE mylist 0 -11) "four"2) "five"3) "three"redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; String indexNewValue = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().set(randomListKey, 1, indexNewValue); logger.info("LSET &#123;&#125; 1 &#123;&#125;", randomListKey, indexNewValue); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("rangeResult &gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("lset:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lrem]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flrem%2F</url>
    <content type="text"><![CDATA[语法1LREM key count value 解释从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作： count &gt; 0: 从头往尾移除值为 value 的元素。 count &lt; 0: 从尾往头移除值为 value 的元素。 count = 0: 移除所有值为 value 的元素。比如， LREM list -2 “hello” 会从存于 list 的列表里移除最后两个出现的 “hello”。 需要注意的是，如果list里没有存在key就会被当作空list处理，所以当 key 不存在的时候，这个命令会返回 0。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the length of the list. 返回值: 被移除的元素个数。 redis-cli 例子1234567891011121314redis&gt; RPUSH mylist "hello"(integer) 1redis&gt; RPUSH mylist "hello"(integer) 2redis&gt; RPUSH mylist "foo"(integer) 3redis&gt; RPUSH mylist "hello"(integer) 4redis&gt; LREM mylist -2 "hello"(integer) 2redis&gt; LRANGE mylist 0 -11) "hello"2) "foo"redis&gt; Spring Boot例子1234567891011121314151617181920212223242526272829303132333435363738394041private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("默认测试") void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; // 获取第一个元素 String firstEle = stringRedisTemplate.opsForList().index(randomListKey, 0); logger.info("firstEle is &#123;&#125;", firstEle); assert firstEle != null; Long removeResult = stringRedisTemplate.opsForList().remove(randomListKey, 0, firstEle); logger.info("LREM &#123;&#125; 0 &#123;&#125; -&gt; &#123;&#125;", randomListKey, firstEle, removeResult); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("range result -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; /** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */ private String getRandomList(int eleCount) &#123; String listTestKey = String.format("lrem:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lrange]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flrange%2F</url>
    <content type="text"><![CDATA[语法1LRANGE key start stop 解释返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。 偏移量也可以是负数，表示偏移量是从list尾部开始计数。 例如， -1 表示列表的最后一个元素，-2 是倒数第二个，以此类推。 ####在不同编程语言里，关于求范围函数的一致性#### 需要注意的是，如果你有一个list，里面的元素是从0到100，那么 LRANGE list 0 10 这个命令会返回11个元素，即最右边的那个元素也会被包含在内。 在你所使用的编程语言里，这一点可能是也可能不是跟那些求范围有关的函数都是一致的。（像Ruby的 Range.new，Array#slice 或者Python的 range() 函数。） ####超过范围的下标#### 当下标超过list范围的时候不会产生error。 如果start比list的尾部下标大的时候，会返回一个空列表。 如果stop比list的实际尾部大的时候，Redis会当它是最后一个元素的下标。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range. 返回值: array-reply: 指定范围里的列表元素。 redis-cli 例子12345678910111213141516171819redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; LRANGE mylist 0 01) "one"redis&gt; LRANGE mylist -3 21) "one"2) "two"3) "three"redis&gt; LRANGE mylist -100 1001) "one"2) "two"3) "three"redis&gt; LRANGE mylist 5 10(empty list or set)redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String randomListKey = getRandomList(10); try &#123; // start 、end 为要获取元素的开始下标和结束下标 List&lt;String&gt; rangResult = stringRedisTemplate.opsForList().range(randomListKey, 0, 1); assert rangResult != null; rangResult.forEach(s -&gt; logger.info("rangeResult -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;@Test@DisplayName("获取全部元素")void getAllTest() &#123; String randomListKey = getRandomList(10); try &#123; // start = 0 表示从第一个元素 // end = -1 表示最后一个元素 // 连起来的意思就是截取全部元素 List&lt;String&gt; rangResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangResult != null; rangResult.forEach(s -&gt; logger.info("rangeResult -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;@Test@DisplayName("key不存在时")void invalidTest() &#123; String randomListKey = String.format("lrange:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", randomListKey); try &#123; // 此时key是不在于redis的、结果是没有的 List&lt;String&gt; rangResult = stringRedisTemplate.opsForList().range(randomListKey, 0, 11); assert rangResult != null; rangResult.forEach(s -&gt; logger.info("rangeResult -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("lrange:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lpushx]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flpushx%2F</url>
    <content type="text"><![CDATA[语法1LPUSHX key value 解释只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: Integer,在 push 操作后的 list 长度。 redis-cli 例子123456789101112redis&gt; LPUSH mylist "World"(integer) 1redis&gt; LPUSHX mylist "Hello"(integer) 2redis&gt; LPUSHX myotherlist "Hello"(integer) 0redis&gt; LRANGE mylist 0 -11) "Hello"2) "World"redis&gt; LRANGE myotherlist 0 -1(empty list or set)redis&gt; Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("key存在时") void keyExistTest() &#123; String randomListKey = getRandomList(12); try &#123; String newValue = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().leftPushIfPresent(randomListKey, newValue); logger.info("LPUSHX &#123;&#125; &#123;&#125;", randomListKey, newValue); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("keyExistTest,rangeResult -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; @Test @DisplayName("key不存在时") void keyNotExistTest() &#123; // 如果是0则意味着不会PUSH元素到List里面也就不存在与Redis String randomListKey = getRandomList(0); try &#123; String newValue = UUID.randomUUID().toString(); stringRedisTemplate.opsForList().leftPushIfPresent(randomListKey, newValue); logger.info("LPUSHX &#123;&#125; &#123;&#125;", randomListKey, newValue); List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert rangeResult != null; rangeResult.forEach(s -&gt; logger.info("keyNotExistTest,rangeResult -&gt; &#123;&#125;", s)); // 如果key不存在的时候，则不会存入进去 &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125; &#125; /** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */ private String getRandomList(int eleCount) &#123; String listTestKey = String.format("lpushx:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lpush]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flpush%2F</url>
    <content type="text"><![CDATA[语法1LPUSH key value [value ...] 解释将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。 可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令例子 LPUSH mylist a b c，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integer,在 push 操作后的 list 长度。 历史： 版本老于 2.4 的 Redis 只能每条命令 push 一个值。 redis-cli 例子12345678redis&gt; LPUSH mylist "world"(integer) 1redis&gt; LPUSH mylist "hello"(integer) 2redis&gt; LRANGE mylist 0 -11) "hello"2) "world"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("常规测试")void genericTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; // LPUSH testKey world Long lPushResult1 = stringRedisTemplate.opsForList().leftPush(testKey, "world"); logger.info("LPUSH testKey world =&gt; &#123;&#125;", lPushResult1); // LPUSH testKey hello Long lPushResult2 = stringRedisTemplate.opsForList().leftPush(testKey, "hello"); logger.info("LPUSH testKey hello =&gt; &#123;&#125;", lPushResult2); // LRANGE testKey 0 -1 List&lt;String&gt; rangeResult = stringRedisTemplate.opsForList().range(testKey, 0, -1); if (CollectionUtils.isEmpty(rangeResult)) &#123; throw new BaseException("LRANGE 结果为空"); &#125; rangeResult.forEach(s -&gt; logger.info("rangeResult:&#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lpop]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flpop%2F</url>
    <content type="text"><![CDATA[语法1LPOP key 解释移除并且返回 key 对应的 list 的第一个元素。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: 1.0.0 返回值: 返回第一个元素的值，或者当 key 不存在时返回 nil。 redis-cli 例子123456789101112redis&gt; RPUSH mylist "one"(integer) 1redis&gt; RPUSH mylist "two"(integer) 2redis&gt; RPUSH mylist "three"(integer) 3redis&gt; LPOP mylist"one"redis&gt; LRANGE mylist 0 -11) "two"2) "three"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("list存在时候的测试")void listExistsTest()&#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); logger.info("now testKey is &#123;&#125;",testKey); try &#123; // 存入testKey 一个元素one // LPUSH testKey one stringRedisTemplate.opsForList().leftPush(testKey,"one"); // 存入testKey 一个元素one // LPUSH testKey two stringRedisTemplate.opsForList().leftPush(testKey,"two"); // 从testKey头部弹出一个元素 // LPOP testKey String popValue = stringRedisTemplate.opsForList().leftPop(testKey); logger.info("LPOP testKey =&gt; &#123;&#125;",popValue); &#125;finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[llen]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fllen%2F</url>
    <content type="text"><![CDATA[语法1LLEN key 解释返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integer,key对应的list的长度。 redis-cli 例子1234567redis&gt; LPUSH mylist "World"(integer) 1redis&gt; LPUSH mylist "Hello"(integer) 2redis&gt; LLEN mylist(integer) 2redis&gt; Spring Boot例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String randomListKey = getRandomList(12); try &#123; Long result = stringRedisTemplate.opsForList().size(randomListKey); logger.info("LLEN &#123;&#125; &gt; &#123;&#125;", randomListKey, result); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String randomListKey = String.format("llen:testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("random testKey is &#123;&#125;", randomListKey); Long result = stringRedisTemplate.opsForList().size(randomListKey); logger.info("LLEN &#123;&#125; &gt; &#123;&#125;", randomListKey, result); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("llen:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linsert]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flinsert%2F</url>
    <content type="text"><![CDATA[语法1LINSERT key BEFORE|AFTER pivot value 解释把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。 当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。 当 key 存在，但保存的不是一个list的时候，会返回error。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N). 返回值: Integer,经过插入操作后的list长度，或者当 pivot 值找不到的时候返回 -1。 redis-cli 例子1234567891011redis&gt; RPUSH mylist "Hello"(integer) 1redis&gt; RPUSH mylist "World"(integer) 2redis&gt; LINSERT mylist BEFORE "World" "There"(integer) 3redis&gt; LRANGE mylist 0 -11) "Hello"2) "There"3) "World"redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String randomListKey = getRandomList(10); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); try &#123; // 获取最后一个元素 List&lt;String&gt; lastEleList = stringRedisTemplate.opsForList().range(randomListKey, -1, -1); Assertions.assertTrue(CollectionUtils.isNotEmpty(lastEleList)); String lastEle = lastEleList.get(0); logger.info("GET lastEle is &#123;&#125;", lastEle); // 然后把最后一个元素插入到最后 Long result = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; &#123; byte[] keyBytes = keySerializer.serialize(randomListKey); byte[] pivotBytes = valueSerializer.serialize(lastEle); byte[] valueBytes = valueSerializer.serialize(lastEle); assert keyBytes != null; assert pivotBytes != null; assert valueBytes != null; return connection.lInsert(keyBytes, RedisListCommands.Position.AFTER, pivotBytes, valueBytes); &#125;); logger.info("LINSERT &#123;&#125; AFTER &#123;&#125; &#123;&#125; &gt; &#123;&#125;", randomListKey, lastEle, lastEle, result); List&lt;String&gt; allEle = stringRedisTemplate.opsForList().range(randomListKey, 0, -1); assert allEle != null; allEle.forEach(s -&gt; logger.info("allEle -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随机的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("linsert:listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lindex]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Flindex%2F</url>
    <content type="text"><![CDATA[语法1LINDEX key index 解释返回key对应列表里第index个元素 （下标方式取元素）下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。 当 key 对应的值不是一个列表的时候，会返回一个error。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1). 返回值: 请求的对应元素，或者当 index 超过范围的时候返回 nil。 redis-cli 例子1234567891011redis&gt; LPUSH mylist "World"(integer) 1redis&gt; LPUSH mylist "Hello"(integer) 2redis&gt; LINDEX mylist 0"Hello"redis&gt; LINDEX mylist -1"World"redis&gt; LINDEX mylist 3(nil)redis&gt; Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("index在范围内")void validIndexTest() &#123; String randomListKey = getRandomList(10); try &#123; String result = stringRedisTemplate.opsForList().index(randomListKey, 0); logger.info("LINDEX &#123;&#125; 0 &gt; &#123;&#125;", randomListKey, result); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;@Test@DisplayName("index不在范围内")void invalidIndexTest() &#123; String randomListKey = getRandomList(10); try &#123; String result = stringRedisTemplate.opsForList().index(randomListKey, 10); logger.info("LINDEX &#123;&#125; 10 &gt; &#123;&#125;", randomListKey, result); &#125; finally &#123; stringRedisTemplate.delete(randomListKey); &#125;&#125;/** * 获取一个随及的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("listTestKey:%s", UUID.randomUUID().toString()); logger.info("random testKey is &#123;&#125;", listTestKey); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brpoplpush]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fbrpoplpush%2F</url>
    <content type="text"><![CDATA[语法1BRPOPLPUSH source destination timeout 解释BRPOPLPUSH 是 RPOPLPUSH 的阻塞版本。 当 source 包含元素的时候，这个命令表现得跟 RPOPLPUSH 一模一样。 当 source 是空的时候，Redis将会阻塞这个连接，直到另一个客户端 push 元素进入或者达到 timeout 时限。 timeout 为 0 能用于无限期阻塞客户端。 查看 RPOPLPUSH 以了解更多信息。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: 批量回复(bulk-reply): 元素从 source 中弹出来，并压入 destination 中。 如果达到 timeout 时限，会返回一个空的多批量回复(nil-reply)。 redis-cli 例子12 Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; List&lt;String&gt; listTestKeyList = new ArrayList&lt;&gt;(); try &#123; String list1TestKey = getRandomList(4); String list2TestKey = getRandomList(1); logger.info("list1TestKey -&gt; &#123;&#125;", list1TestKey); logger.info("list2TestKey -&gt; &#123;&#125;", list2TestKey); listTestKeyList.add(list1TestKey); listTestKeyList.add(list2TestKey); String result = stringRedisTemplate.opsForList().rightPopAndLeftPush(list1TestKey, list2TestKey, 1, TimeUnit.SECONDS); logger.info("BRPOPLPUSH &#123;&#125; &#123;&#125; -&gt; &#123;&#125;", list1TestKey, list2TestKey, result); // 获取现在list1所有元素 List&lt;String&gt; list1ValueList = stringRedisTemplate.opsForList().range(list1TestKey, 0, -1); // 获取现在list2所有元素 List&lt;String&gt; list2ValueList = stringRedisTemplate.opsForList().range(list2TestKey, 0, -1); Assertions.assertNotNull(list1ValueList); Assertions.assertNotNull(list2ValueList); list1ValueList.forEach(s -&gt; logger.info("&#123;&#125; -&gt; &#123;&#125;", list1TestKey, s)); list2ValueList.forEach(s -&gt; logger.info("&#123;&#125; -&gt; &#123;&#125;", list2TestKey, s)); &#125; finally &#123; stringRedisTemplate.delete(listTestKeyList); &#125;&#125;/** * 获取一个随及的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("listTestKey:%s", UUID.randomUUID().toString()); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brpop]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fbrpop%2F</url>
    <content type="text"><![CDATA[语法1BRPOP key [key ...] timeout 解释BRPOP 是一个阻塞的列表弹出原语。 它是 RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。 请在 BLPOP 文档 中查看该命令的准确语义，因为 BRPOP 和 BLPOP 基本是完全一样的，除了它们一个是从尾部弹出元素，而另一个是从头部弹出元素。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 多批量回复(multi-bulk-reply): 具体来说: 当没有元素可以被弹出时返回一个 nil 的多批量值，并且 timeout 过期。 当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。 redis-cli 例子1234567redis&gt; DEL list1 list2(integer) 0redis&gt; RPUSH list1 a b c(integer) 3redis&gt; BRPOP list1 list2 01) "list1"2) "c" Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private Logger logger = LoggerFactory.getLogger(getClass()); @Resource private StringRedisTemplate stringRedisTemplate; @Test @DisplayName("默认测试") void genericTest() &#123; List&lt;String&gt; listTestKeyList = new ArrayList&lt;&gt;(); try &#123; String list1TestKey = getRandomList(0); String list2TestKey = getRandomList(4); String list3TestKey = getRandomList(5); logger.info("list1TestKey -&gt; &#123;&#125;", list1TestKey); logger.info("list2TestKey -&gt; &#123;&#125;", list2TestKey); logger.info("list3TestKey -&gt; &#123;&#125;", list3TestKey); listTestKeyList.add(list1TestKey); listTestKeyList.add(list2TestKey); listTestKeyList.add(list3TestKey); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); List&lt;String&gt; resultList = stringRedisTemplate.execute((RedisCallback&lt;List&lt;String&gt;&gt;) connection -&gt; &#123; List&lt;String&gt; resultStringList = new ArrayList&lt;&gt;(); // 序列化多个Key byte[][] multiKeys = serializeMulti(keySerializer, list1TestKey, list2TestKey, list3TestKey); // 超时时间为1秒 List&lt;byte[]&gt; resultBytes = connection.bRPop(1, multiKeys); if (CollectionUtils.isNotEmpty(resultBytes)) &#123; // 把返回的byte数组序反列化为string resultBytes.forEach(bytes -&gt; resultStringList.add(valueSerializer.deserialize(bytes))); &#125; return resultStringList; &#125;); // 非空判断 Assertions.assertNotNull(resultList); // 输出结果 resultList.forEach(s -&gt; logger.info("resultList -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(listTestKeyList); &#125; // 本命令为堵塞从列表头部弹出最后一个元素 // 也就是说即便提供了多个key，如果从左到右中key有非空的 // 则会弹出从左到右第一个非空的key的最后一个元素 // 相反 如果提供的key都无元素，则会堵塞，这时超时时间便起作用了 &#125; /** * 序列化多个key * * @param keySerializer key序列化器 从redisTemplate得到 * @param keys 多个key * @param &lt;T&gt; key的类型 * @return 序列化后的二维bytes数组 */ @SafeVarargs private final &lt;T&gt; byte[][] serializeMulti(RedisSerializer&lt;T&gt; keySerializer, T... keys) &#123; if (keys == null) &#123; return new byte[0][]; &#125; byte[][] ret = new byte[keys.length][]; for (int i = 0; i &lt; ret.length; i++) &#123; ret[i] = keySerializer.serialize(keys[i]); &#125; return ret; &#125; /** * 获取一个随及的list * * @param eleCount list 元素个数 * @return listTestKey */ private String getRandomList(int eleCount) &#123; String listTestKey = String.format("listTestKey:%s", UUID.randomUUID().toString()); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey; &#125;]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blpop]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fblpop%2F</url>
    <content type="text"><![CDATA[语法1BLPOP key [key ...] timeout 解释BLPOP 是阻塞式列表的弹出原语。 它是命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候， 连接将被 BLPOP 命令阻塞。 当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。 非阻塞行为当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。 当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：1BLPOP list1 list2 list3 0 阻塞行为如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接， 直到有另一个客户端对给定的这些 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。 一旦有新的数据出现在其中一个列表里，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。 当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候， 若经过了指定的 timeout 仍没有出现一个针对某一特定 key 的 push 操作，则客户端会解除阻塞状态并且返回一个 nil 的多组合值(multi-bulk value)。 timeout 参数表示的是一个指定阻塞的最大秒数的整型值。当 timeout 为 0 是表示阻塞时间无限制。 什么 key 会先被处理？是什么客户端？什么元素？优先顺序细节。 当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 BLPOP key1 key2 key3 key4 0，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。 当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该key而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 BLPOP 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。 当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个Lua脚本向多个list添加元素）， 那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。 从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis就会对所有等待这个key的客户端按照“先进先出”(FIFO)的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。 当多个元素被 push 进入一个 list 时 BLPOP 的行为有时候一个 list 会在同一概念的命令的情况下接收到多个元素： 像 LPUSH mylist a b c 这样的可变 push 操作。 在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。 使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。 对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。12Client A: BLPOP foo 0Client B: LPUSH foo a b c 如果上面的情况是发生在 Redis 2.6 或更高版本的服务器上，客户端 A 会接收到 c 元素，因为在 LPUSH 命令执行后，list 包含了 c,b,a 这三个元素，所以从左边取一个元素就会返回 c。 相反，Redis 2.4 是以不同的方式工作的：客户端会在 push 操作的上下文中被服务，所以当 LPUSH foo a b c 开始往 list 中 push 第一个元素，它就被传送给客户端A，也就是客户端A会接收到 a（第一个被 push 的元素）。 Redis 2.4的这种行为会在复制或者持续把数据存入AOF文件的时候引发很多问题，所以为了防止这些问题，很多更一般性的、并且在语义上更简单的行为被引入到 Redis 2.6 中。 需要注意的是，一个Lua脚本或者一个 MULTI / EXEC 块可能会 push 一堆元素进入一个 list 后，再 删除这个 list。 在这种情况下，被阻塞的客户端完全不会被服务，并且只要在执行某个单一命令、事务或者脚本后 list 中没有出现元素，它就会被继续阻塞下去。 在一个 MULTI / EXEC 事务中的 BLPOPBLPOP 可以用于流水线（pipeline，发送多个命令并且批量读取回复），特别是当它是流水线里的最后一个命令的时候，这种设定更加有意义。 在一个 MULTI / EXEC 块里面使用 BLPOP 并没有很大意义，因为它要求整个服务器被阻塞以保证块执行时的原子性，这就阻止了其他客户端执行一个 push 操作。 因此，一个在 MULTI / EXEC 里面的 BLPOP 命令会在 list 为空的时候返回一个 nil 值，这跟超时(timeout)的时候发生的一样。 如果你喜欢科幻小说，那么想象一下时间是以无限的速度在 MULTI / EXEC 块中流逝…… 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: 多批量回复(multi-bulk-reply): 具体来说: 当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。 当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。 redis-cli 例子1234567redis&gt; DEL list1 list2(integer) 0redis&gt; RPUSH list1 a b c(integer) 3redis&gt; BLPOP list1 list2 01) "list1"2) "a" Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; List&lt;String&gt; listTestKeyList = new ArrayList&lt;&gt;(); try &#123; String list1TestKey = getRandomList(1); String list2TestKey = getRandomList(2); String list3TestKey = getRandomList(3); logger.info("list1TestKey -&gt; &#123;&#125;", list1TestKey); logger.info("list2TestKey -&gt; &#123;&#125;", list2TestKey); logger.info("list3TestKey -&gt; &#123;&#125;", list3TestKey); listTestKeyList.add(list1TestKey); listTestKeyList.add(list2TestKey); listTestKeyList.add(list3TestKey); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); List&lt;String&gt; resultList = stringRedisTemplate.execute((RedisCallback&lt;List&lt;String&gt;&gt;) connection -&gt; &#123; List&lt;String&gt; resultStringList = new ArrayList&lt;&gt;(); // 序列化多个Key byte[][] multiKeys = serializeMulti(keySerializer, list1TestKey, list2TestKey, list3TestKey); // 超时时间为1秒 List&lt;byte[]&gt; resultBytes = connection.bLPop(1, multiKeys); if (CollectionUtils.isNotEmpty(resultBytes)) &#123; // 把返回的byte数组序反列化为string resultBytes.forEach(bytes -&gt; resultStringList.add(valueSerializer.deserialize(bytes))); &#125; return resultStringList; &#125;); // 非空判断 Assertions.assertNotNull(resultList); // 输出结果 resultList.forEach(s -&gt; logger.info("resultList -&gt; &#123;&#125;", s)); &#125; finally &#123; stringRedisTemplate.delete(listTestKeyList); &#125; // 本命令为堵塞从列表头部弹出一个元素 // 也就是说即便提供了多个key，如果从左到右中key有非空的 // 则会弹出从左到右第一个非空的key的第一个元素 // 相反 如果提供的key都无元素，则会堵塞，这时超时时间便起作用了&#125;/** * 序列化多个key * * @param keySerializer key序列化器 从redisTemplate得到 * @param keys 多个key * @param &lt;T&gt; key的类型 * @return 序列化后的二维bytes数组 */@SafeVarargsprivate final &lt;T&gt; byte[][] serializeMulti(RedisSerializer&lt;T&gt; keySerializer, T... keys) &#123; if (keys == null) &#123; return new byte[0][]; &#125; byte[][] ret = new byte[keys.length][]; for (int i = 0; i &lt; ret.length; i++) &#123; ret[i] = keySerializer.serialize(keys[i]); &#125; return ret;&#125;/** * 获取一个随及的list * * @param eleCount list 元素个数 * @return listTestKey */private String getRandomList(int eleCount) &#123; String listTestKey = String.format("listTestKey:%s", UUID.randomUUID().toString()); char listValuePrefix = listTestKey.charAt(listTestKey.length() - 1); for (int i = 0; i &lt; eleCount; i++) &#123; String value = String.format("%c_%d", listValuePrefix, i); stringRedisTemplate.opsForList().rightPush(listTestKey, value); logger.info("RPUSH &#123;&#125; &#123;&#125;", listTestKey, value); &#125; return listTestKey;&#125; 可靠的队列当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。 在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，请查看 BRPOPLPUSH 命令，这是 BLPOP 的一个变形，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。 模式：事件提醒用来阻塞 list 的操作有可能是不同的阻塞原语。 比如在某些应用里，你也许会为了等待新元素进入 Redis Set 而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。 这就要求要有一个 SPOP 的阻塞版本，而这事实上并不可用。但是我们可以通过阻塞 list 操作轻易完成这个任务。 消费者会做的：123456LOOP forever WHILE SPOP(key) returns elements ... process elements ... END BRPOP helper_keyEND 而在生产者这角度我们可以这样简单地使用：1234MULTISADD key elementLPUSH helper_key xEXEC]]></content>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strlen]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fstrlen%2F</url>
    <content type="text"><![CDATA[语法1STRLEN key 解释返回key的string类型value的长度。如果key对应的非string类型，就返回错误。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: Integer,key对应的字符串value的长度，或者0（key不存在） redis-cli 例子1234567redis&gt; SET mykey "Hello world"OKredis&gt; STRLEN mykey(integer) 11redis&gt; STRLEN nonexisting(integer) 0redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setrange]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fsetrange%2F</url>
    <content type="text"><![CDATA[语法1SETRANGE key offset value 解释这个命令的作用是覆盖key对应的string的一部分，从指定的offset处开始，覆盖value的长度。如果offset比当前key对应string还要长，那这个string后面就补0以达到offset。不存在的keys被认为是空字符串，所以这个命令可以确保key有一个足够大的字符串，能在offset处设置value。 注意，offset最大可以是229-1(536870911),因为redis字符串限制在512M大小。如果你需要超过这个大小，你可以用多个keys。 警告：当set最后一个字节并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，set536870911字节（分配512MB）需要～300ms，set134217728字节(分配128MB)需要～80ms，set33554432比特位（分配32MB）需要～30ms，set8388608比特（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETRANGE就不会预先得到内存分配。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument. 返回值: Integer,该命令修改后的字符串长度 redis-cli 例子基本使用方法1234567redis&gt; SET key1 "Hello World"OKredis&gt; SETRANGE key1 6 "Redis"(integer) 11redis&gt; GET key1"Hello Redis"redis&gt; 补0的例子12345redis&gt; SETRANGE key2 6 "Redis"(integer) 11redis&gt; GET key2"\x00\x00\x00\x00\x00\x00Redis"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setnx]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fsetnx%2F</url>
    <content type="text"><![CDATA[语法1SETNX key value 解释将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是”SET if Not eXists”的简写。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integer 1 如果key被设置了 0 如果key没有被设置 redis-cli 例子1234567redis&gt; SETNX mykey "Hello"(integer) 1redis&gt; SETNX mykey "World"(integer) 0redis&gt; GET mykey"Hello"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setex]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fsetex%2F</url>
    <content type="text"><![CDATA[语法1SETEX key seconds value 解释设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令：12SET mykey valueEXPIRE mykey seconds SETEX是原子的，也可以通过把上面两个命令放到MULTI/EXEC块中执行的方式重现。相比连续执行上面两个命令，它更快，因为当Redis当做缓存使用时，这个操作更加常用。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1) 返回值: OK redis-cli 例子123456redis&gt; SETEX mykey 10 “Hello” OK redis&gt; TTL mykey (integer) 10 redis&gt; GET mykey “Hello” redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setbit]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fsetbit%2F</url>
    <content type="text"><![CDATA[语法1SETBIT key offset value 解释设置或者清空key的value(字符串)在offset处的bit值。 那个位置的bit要么被设置，要么被清空，这个由value（只能是0或者1）来决定。当key不存在的时候，就创建一个新的字符串value。要确保这个字符串大到在offset处有bit值。参数offset需要大于等于0，并且小于232(限制bitmap大小为512)。当key对应的字符串增大的时候，新增的部分bit值都是设置为0。 警告：当set最后一个bit(offset等于232-1)并且key还没有一个字符串value或者其value是个比较小的字符串时，Redis需要立即分配所有内存，这有可能会导致服务阻塞一会。在一台2010MacBook Pro上，offset为232-1（分配512MB）需要～300ms，offset为230-1(分配128MB)需要～80ms，offset为228-1（分配32MB）需要～30ms，offset为226-1（分配8MB）需要8ms。注意，一旦第一次内存分配完，后面对同一个key调用SETBIT就不会预先得到内存分配。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: 在offset处原来的bit值 redis-cli 例子1234567redis&gt; SETBIT mykey 7 1(integer) 0redis&gt; SETBIT mykey 7 0(integer) 1redis&gt; GET mykey"\x00"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fset%2F</url>
    <content type="text"><![CDATA[语法1SET key value [EX seconds] [PX milliseconds] [NX|XX] 解释将键key设定为指定的“字符串”值。 如果 key 已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。 当set命令执行成功之后，之前设置的过期时间都将失效 选项从2.6.12版本开始，redis为SET命令增加了一系列选项: EX seconds – 设置键key的过期时间，单位时秒 PX milliseconds – 设置键key的过期时间，单位时毫秒 NX – 只有键key不存在的时候才会设置key的值 XX – 只有键key存在的时候才会设置key的值注意: 由于SET命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，所以在将来的版本中，redis可能会不推荐使用并且最终抛弃这几个命令。扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: 如果SET命令正常执行那么回返回OK，否则如果加了NX 或者 XX选项，但是没有设置条件。那么会返回nil。 redis-cli 例子12345redis&gt; SET mykey "Hello"OKredis&gt; GET mykey"Hello"redis&gt; Spring Boot例子12 设计模式注意: 下面这种设计模式并不推荐用来实现redis分布式锁。应该参考the Redlock algorithm的实现，因为这个方法只是复杂一点，但是却能保证更好的使用效果。 命令 SET resource-name anystring NX EX max-lock-time 是一种用 Redis 来实现锁机制的简单方法。 如果上述命令返回OK，那么客户端就可以获得锁（如果上述命令返回Nil，那么客户端可以在一段时间之后重新尝试），并且可以通过DEL命令来释放锁。 客户端加锁之后，如果没有主动释放，会在过期时间之后自动释放。 可以通过如下优化使得上面的锁系统变得更加鲁棒： 不要设置固定的字符串，而是设置为随机的大字符串，可以称为token。通过脚步删除指定锁的key，而不是DEL命令。上述优化方法会避免下述场景：a客户端获得的锁（键key）已经由于过期时间到了被redis服务器删除，但是这个时候a客户端还去执行DEL命令。而b客户端已经在a设置的过期时间之后重新获取了这个同样key的锁，那么a执行DEL就会释放了b客户端加好的锁。 解锁脚本的一个例子将类似于以下：123456if redis.call("get",KEYS[1]) == ARGV[1]then return redis.call("del",KEYS[1])else return 0end]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[psetex]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fpsetex%2F</url>
    <content type="text"><![CDATA[语法1PSETEX key milliseconds value 解释设置key对应字符串value，并且设置key在给定的milliseconds时间之后超时过期。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: OK redis-cli 例子1234567redis&gt; PSETEX mykey 1000 "Hello"OKredis&gt; PTTL mykey(integer) 999redis&gt; GET mykey"Hello"redis&gt; Spring Boot例子12]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msetnx]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fmsetnx%2F</url>
    <content type="text"><![CDATA[语法1MSETNX key value [key value ...] 解释对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。 MSETNX是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。 扩展 支持版本: &gt;= 1.0.1 时间复杂度: O(N) where N is the number of keys to set. 返回值: 只有以下两种值 1 如果所有的key被set 0 如果没有key被set(至少其中有一个key是存在的) redis-cli 例子123456789redis&gt; MSETNX key1 "Hello" key2 "there"(integer) 1redis&gt; MSETNX key2 "there" key3 "world"(integer) 0redis&gt; MGET key1 key2 key31) "Hello"2) "there"3) (nil)redis&gt;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mset]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fmset%2F</url>
    <content type="text"><![CDATA[语法1MSET key value [key value ...] 解释对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。 MSET是原子的，所以所有给定的keys是一次性set的。客户端不可能看到这种一部分keys被更新而另外的没有改变的情况。 扩展 支持版本: &gt;= 1.0.1 时间复杂度: O(N) where N is the number of keys to set. 返回值: 总是OK，因为MSET不会失败。 redis-cli 例子1234567redis&gt; MSET key1 "Hello" key2 "World"OKredis&gt; GET key1"Hello"redis&gt; GET key2"World"redis&gt;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mget]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fmget%2F</url>
    <content type="text"><![CDATA[解释返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(N) where N is the number of keys to retrieve. 返回值: list,指定的key对应的values的list redis-cli 例子123456789redis&gt; SET key1 "Hello"OKredis&gt; SET key2 "World"OKredis&gt; MGET key1 key2 nonexisting1) "Hello"2) "World"3) (nil)redis&gt;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[incrbyfloat]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fincrbyfloat%2F</url>
    <content type="text"><![CDATA[解释通过指定浮点数key来增长浮点数(存放于string中)的值. 当键不存在时,先将其值设为0再操作.下面任一情况都会返回错误: key 包含非法值(不是一个string). 当前的key或者相加后的值不能解析为一个双精度的浮点值.(超出精度范围了) 如果操作命令成功, 相加后的值将替换原值存储在对应的键值上, 并以string的类型返回. string中已存的值或者相加参数可以任意选用指数符号,但相加计算的结果会以科学计数法的格式存储. 无论各计算的内部精度如何, 输出精度都固定为小数点后17位. 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(1) 返回值: String,执行递增操作后key对应的值。 redis-cli 例子12345678redis&gt; SET mykey 10.50OKredis&gt; INCRBYFLOAT mykey 0.1"10.6"redis&gt; SET mykey 5.0e3OKredis&gt; INCRBYFLOAT mykey 2.0e2"5200" SpringBoot 例子1234567891011121314151617181920212223242526private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; // 设置testKey为10.50 stringRedisTemplate.opsForValue().set(testKey, "10.50"); logger.info("SET testKey 10.50"); // INCRBYFLOAT testKey 0.1 Double incrByFloatResult1 = stringRedisTemplate.opsForValue().increment(testKey, 0.1); logger.info("INCRBYFLOAT testKey 2.0e2 =&gt; &#123;&#125;", incrByFloatResult1); // SET testKey 5.0e3 stringRedisTemplate.opsForValue().set(testKey, "5.0e3"); logger.info(" SET testKey 5.0e3"); // INCRBYFLOAT testKey 2.0e2 Double incrByFloatResult2 = stringRedisTemplate.opsForValue().increment(testKey, 2.0e2); logger.info("INCRBYFLOAT testKey 2.0e2 =&gt; &#123;&#125;", incrByFloatResult2); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[incrby]]></title>
    <url>%2Fredis%2F2018%2F05%2F16%2Fincrby%2F</url>
    <content type="text"><![CDATA[解释将key对应的数字加decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integers,执行递增操作后key对应的值。 redis-cli 例子12345redis&gt; SET mykey "10"OKredis&gt; INCRBY mykey 5(integer) 15redis&gt; SpringBoot 例子12345678910111213141516171819private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; // 设置testKey的值为1024 stringRedisTemplate.opsForValue().set(testKey, "1024"); // incrby testKey 200 Long incrbyResult = stringRedisTemplate.opsForValue().increment(testKey, 200); logger.info("incrbyResult:&#123;&#125;", incrbyResult); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[incr]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fincr%2F</url>
    <content type="text"><![CDATA[解释对存储在指定key的数值执行原子的加1操作。 如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。 如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数， 那么执行这个命令时服务器会返回一个错误(eq:(error) ERR value is not an integer or out of range)。 这个操作仅限于64位的有符号整型数据。 注意由于redis并没有一个明确的类型来表示整型数据，所以这个操作是一个字符串操作。 执行这个操作的时候，key对应存储的字符串被解析为10进制的64位有符号整型数据。 事实上，Redis 内部采用整数形式（Integer representation）来存储对应的整数值，所以对该类字符串值实际上是用整数保存，也就不存在存储整数的字符串表示（String representation）所带来的额外消耗。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integers,执行递增操作后key对应的值。 redis-cli 例子1234567redis&gt; SET mykey "10"OKredis&gt; INCR mykey(integer) 11redis&gt; GET mykey"11"redis&gt; SpringBoot 例子123456789101112131415161718192021222324252627282930313233343536private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("testKey存在测试")void keyExistsTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); try &#123; // 设置testKey的值为1024 stringRedisTemplate.opsForValue().set(testKey, "1024"); // incr testKey Long incrResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.incr(testKeySerializeBytes)); logger.info("incrResult:&#123;&#125;", incrResult); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("testKey不存在测试")void keyNotExistsTest()&#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); try &#123; // incr testKey Long incrResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.incr(testKeySerializeBytes)); logger.info("incrResult:&#123;&#125;", incrResult); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125; 实例：计数器Redis的原子递增操作最常用的使用场景是计数器。 使用思路是：每次有相关操作的时候，就向Redis服务器发送一个incr命令。 例如这样一个场景：我们有一个web应用，我们想记录每个用户每天访问这个网站的次数。 web应用只需要通过拼接用户id和代表当前时间的字符串作为key，每次用户访问这个页面的时候对这个key执行一下incr命令。 这个场景可以有很多种扩展方法: 通过结合使用INCR和EXPIRE命令，可以实现一个只记录用户在指定间隔时间内的访问次数的计数器 客户端可以通过GETSET命令获取当前计数器的值并且重置为0 通过类似于DECR或者INCRBY等原子递增/递减的命令，可以根据用户的操作来增加或者减少某些值 比如在线游戏，需要对用户的游戏分数进行实时控制，分数可能增加也可能减少。 实例：限速器限速器是一种可以限制某些操作执行速率的特殊场景。 传统的例子就是限制某个公共api的请求数目。 假设我们要解决如下问题：限制某个api每秒每个ip的请求次数不超过10次。 我们可以通过incr命令来实现两种方法解决这个问题。 实例: 限速器 1更加简单和直接的实现如下：12345678910111213FUNCTION LIMIT_API_CALL(ip)ts = CURRENT_UNIX_TIME()keyname = ip+":"+tscurrent = GET(keyname)IF current != NULL AND current &gt; 10 THEN ERROR "too many requests per second"ELSE MULTI INCR(keyname,1) EXPIRE(keyname,10) EXEC PERFORM_API_CALL()END 实例: 限速器 2另外一个实现是对每个ip只用一个单独的计数器（不是每秒生成一个），但是需要注意避免竟态条件。 我们会对多种不同的变量进行测试。1234567891011FUNCTION LIMIT_API_CALL(ip):current = GET(ip)IF current != NULL AND current &gt; 10 THEN ERROR "too many requests per second"ELSE value = INCR(ip) IF value == 1 THEN EXPIRE(value,1) END PERFORM_API_CALL()END 上述方法的思路是，从第一个请求开始设置过期时间为1秒。如果1秒内请求数超过了10个，那么会抛异常。 否则，计数器会清零。 上述代码中，可能会进入竞态条件，比如客户端在执行INCR之后，没有成功设置EXPIRE时间。这个ip的key 会造成内存泄漏，直到下次有同一个ip发送相同的请求过来。 把上述INCR和EXPIRE命令写在lua脚本并执行EVAL命令可以避免上述问题（只有redis版本&gt;＝2.6才可以使用） 12345local currentcurrent = redis.call("incr",KEYS[1])if tonumber(current) == 1 then redis.call("expire",KEYS[1],1)end 还可以通过使用redis的list来解决上述问题避免进入竞态条件。 实现代码更加复杂并且利用了一些redis的新的feature，可以记录当前请求的客户端ip地址。这个有没有好处 取决于应用程序本身。 FUNCTION LIMIT_API_CALL(ip) current = LLEN(ip) IF current &gt; 10 THEN ERROR "too many requests per second" ELSE IF EXISTS(ip) == FALSE MULTI RPUSH(ip,ip) EXPIRE(ip,1) EXEC ELSE RPUSHX(ip,ip) END PERFORM_API_CALL() END The RPUSHX command only pushes the element if the key already exists. RPUSHX命令会往list中插入一个元素，如果key存在的话 上述实现也可能会出现竞态，比如我们在执行EXISTS指令之后返回了false，但是另外一个客户端创建了这个key。 后果就是我们会少记录一个请求。但是这种情况很少出现，所以我们的请求限速器还是能够运行良好的。]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getset]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fgetset%2F</url>
    <content type="text"><![CDATA[解释自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。 设计模式 GETSET可以和INCR一起使用实现支持重置的计数功能。举个例子：每当有事件发生的时候，一段程序都会调用INCR给key mycounter加1，但是有时我们需要获取计数器的值，并且自动将其重置为0。这可以通过GETSET mycounter “0”来实现：123INCR mycounterGETSET mycounter "0"GET mycounter 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: String redis-cli 例子1234567redis&gt; INCR mycounter(integer) 1redis&gt; GETSET mycounter "0""1"redis&gt; GET mycounter"0"redis&gt; SpringBoot 例子1234567891011121314151617181920212223242526272829303132333435private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; // 设置testKey的value为1 stringRedisTemplate.opsForValue().set(testKey, "1"); // GETSET testKey String result = stringRedisTemplate.opsForValue().getAndSet(testKey, "2"); logger.info("result is &#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在Test")void keyNotExistTest()&#123; String testKey = String.format("testNotExistKey:%s",UUID.randomUUID().toString()); try &#123; // GETSET testKey String result = stringRedisTemplate.opsForValue().getAndSet(testKey, "2"); logger.info("result is &#123;&#125;", result); &#125;finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getrange]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fgetrange%2F</url>
    <content type="text"><![CDATA[解释警告：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。 这个函数处理超出范围的请求时，都把结果限制在string内。 扩展 支持版本: &gt;= 2.4.0 时间复杂度: O(N) N是字符串长度，复杂度由最终返回长度决定，但由于通过一个字符串创建子字符串是很容易的，它可以被认为是O(1)。 返回值: String redis-cli 例子1234567891011redis&gt; SET mykey "This is a string"OKredis&gt; GETRANGE mykey 0 3"This"redis&gt; GETRANGE mykey -3 -1"ing"redis&gt; GETRANGE mykey 0 -1"This is a string"redis&gt; GETRANGE mykey 10 100"string"redis&gt; SpringBoot 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在测试")void keyExistsTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("序列化testKey失败"); &#125; try &#123; // 设置字符串为hello word stringRedisTemplate.opsForValue().set(testKey, "hello word"); // GETRANGE testKey 0 3 String resultString = stringRedisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; &#123; byte[] resultBytes = connection.getRange(testKeySerializeBytes, 0, 3); if (resultBytes == null) &#123; return null; &#125; return new String(resultBytes); &#125;); logger.info("resultString is &#123;&#125;", resultString); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在测试")void keyNotExistsTest() &#123; String testKey = String.format("testNotKey:%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("序列化testKey失败"); &#125; try &#123; // GETRANGE testKey 0 3 String resultString = stringRedisTemplate.execute((RedisCallback&lt;String&gt;) connection -&gt; &#123; byte[] resultBytes = connection.getRange(testKeySerializeBytes, 0, 13); if (resultBytes == null) &#123; return null; &#125; return new String(resultBytes); &#125;); logger.info("resultString is &#123;&#125;", resultString); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getbit]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fgetbit%2F</url>
    <content type="text"><![CDATA[解释返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间。当key不存在的时候，它就认为是一个空字符串，所以offset总是超出范围，然后value也被认为是由0比特填充的连续空间。到内存分配。 扩展 支持版本: &gt;= 2.2.0 时间复杂度: O(1) 返回值: Integers,在offset处的bit值 redis-cli 例子123456789redis&gt; SETBIT mykey 7 1(integer) 0redis&gt; GETBIT mykey 0(integer) 0redis&gt; GETBIT mykey 7(integer) 1redis&gt; GETBIT mykey 100(integer) 0redis&gt; SpringBoot 例子12345678910111213141516private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("默认测试")void genericTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); // SETBIT mykey 7 1 stringRedisTemplate.opsForValue().setBit(testKey, 7, true); // GETBIT mykey 7 Boolean result = stringRedisTemplate.opsForValue().getBit(testKey, 7); logger.info("result:&#123;&#125;", result);&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fget%2F</url>
    <content type="text"><![CDATA[解释返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: String,key对应的value，或者nil（key不存在时） redis-cli 例子1234567redis&gt; GET nonexisting(nil)redis&gt; SET mykey "Hello"OKredis&gt; GET mykey"Hello"redis&gt; SpringBoot 例子123456789101112131415161718192021222324252627private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); // 设置testKey的value为val stringRedisTemplate.opsForValue().set(testKey, "val"); // get testKey String value = stringRedisTemplate.opsForValue().get(testKey); logger.info("get result is &#123;&#125;", value);&#125;@Test@DisplayName("key不存在")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); // get testKey String value = stringRedisTemplate.opsForValue().get(testKey); logger.info("get result is &#123;&#125;", value);&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[decrby]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fdecrby%2F</url>
    <content type="text"><![CDATA[解释将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integers,减小之后的value redis-cli 例子12345redis&gt; SET mykey "10"OKredis&gt; DECRBY mykey 5(integer) 5redis&gt; SpringBoot 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key不存在的测试")void keyNotExistTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if(testKeySerializeBytes == null)&#123; throw new BaseException("testKey异常"); &#125; try &#123; Long executeResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.decrBy(testKeySerializeBytes, 1)); logger.info("decrBy executeResult:&#123;&#125;", executeResult); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key存在的测试")void keyExistTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if(testKeySerializeBytes == null)&#123; throw new BaseException("testKey异常"); &#125; try &#123; // 设置testKey的值为123 stringRedisTemplate.opsForValue().set(testKey,"123"); // decrBy 1 Long executeResult = stringRedisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.decrBy(testKeySerializeBytes, 1)); logger.info("decrBy executeResult:&#123;&#125;", executeResult); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁]]></title>
    <url>%2Fredis%2F2018%2F05%2F15%2Fdistlock%2F</url>
    <content type="text"><![CDATA[解释分布式锁在很多场景中是非常有用的原语， 不同的进程必须以独占资源的方式实现资源共享就是一个典型的例子。 有很多分布式锁的库和描述怎么实现分布式锁管理器（DLM)的博客,但是每个库的实现方式都不太一样，很多库的实现方式为了简单降低了可靠性，而有的使用了稍微复杂的设计。 这个页面试图提供一个使用Redis实现分布式锁的规范算法。我们提出一种算法，叫Redlock,我们认为这种实现比普通的单实例实现更安全,我们希望redis社区能帮助分析一下这种实现方法，并给我们提供反馈。 安全和活性失效保障按照我们的思路和设计方案，算法只需具备3个特性就可以实现一个最低保障的分布式锁。 安全属性（Safety property）: 独享（相互排斥）。在任意一个时刻，只有一个客户端持有锁。 活性A(Liveness property A): 无死锁。即便持有锁的客户端崩溃（crashed)或者网络被分裂（gets partitioned)，锁仍然可以被获取。 活性B(Liveness property B): 容错。 只要大部分Redis节点都活着，客户端就可以获取和释放锁. 为什么基于故障转移的实现还不够为了更好的理解我们想要改进的方面，我们先分析一下当前大多数基于Redis的分布式锁现状和实现方法. 实现Redis分布式锁的最简单的方法就是在Redis中创建一个key，这个key有一个失效时间（TTL)，以保证锁最终会被自动释放掉（这个对应特性2）。当客户端释放资源(解锁）的时候，会删除掉这个key。 从表面上看，似乎效果还不错，但是这里有一个问题：这个架构中存在一个严重的单点失败问题。如果Redis挂了怎么办？你可能会说，可以通过增加一个slave节点解决这个问题。但这通常是行不通的。这样做，我们不能实现资源的独享,因为Redis的主从同步通常是异步的。 在这种场景（主从结构）中存在明显的竞态: 客户端A从master获取到锁 在master将锁同步到slave之前，master宕掉了。 slave节点被晋级为master节点 客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！ 有时候程序就是这么巧，比如说正好一个节点挂掉的时候，多个客户端同时取到了锁。如果你可以接受这种小概率错误，那用这个基于复制的方案就完全没有问题。否则的话，我们建议你实现下面描述的解决方案。 单Redis实例实现分布式锁的正确方法在尝试克服上述单实例设置的限制之前，让我们先讨论一下在这种简单情况下实现分布式锁的正确做法，实际上这是一种可行的方案，尽管存在竞态，结果仍然是可接受的，另外，这里讨论的单实例加锁方法也是分布式加锁算法的基础。 获取锁使用命令:1SET resource_name my_random_value NX PX 30000 这个命令仅在不存在key的时候才能被执行成功（NX选项），并且这个key有一个30秒的自动失效时间（PX属性）。这个key的值是“my_random_value”(一个随机值），这个值在所有的客户端必须是唯一的，所有同一key的获取者（竞争者）这个值都不能一样。 value的值必须是随机数主要是为了更安全的释放锁，释放锁的时候使用脚本告诉Redis:只有key存在并且存储的值和我指定的值一样才能告诉我删除成功。可以通过以下Lua脚本实现：12345if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1])else return 0end 使用这种方式释放锁可以避免删除别的客户端获取成功的锁。举个例子：客户端A取得资源锁，但是紧接着被一个其他操作阻塞了，当客户端A运行完毕其他操作后要释放锁时，原来的锁早已超时并且被Redis自动释放，并且在这期间资源锁又被客户端B再次获取到。如果仅使用DEL命令将key删除，那么这种情况就会把客户端B的锁给删除掉。使用Lua脚本就不会存在这种情况，因为脚本仅会删除value等于客户端A的value的key（value相当于客户端的一个签名）。 这个随机字符串应该怎么设置？我认为它应该是从/dev/urandom产生的一个20字节随机数，但是我想你可以找到比这种方法代价更小的方法，只要这个数在你的任务中是唯一的就行。例如一种安全可行的方法是使用/dev/urandom作为RC4的种子和源产生一个伪随机流;一种更简单的方法是把以毫秒为单位的unix时间和客户端ID拼接起来，理论上不是完全安全，但是在多数情况下可以满足需求. key的失效时间，被称作“锁定有效期”。它不仅是key自动失效时间，而且还是一个客户端持有锁多长时间后可以被另外一个客户端重新获得。 截至到目前，我们已经有较好的方法获取锁和释放锁。基于Redis单实例，假设这个单实例总是可用，这种方法已经足够安全。现在让我们扩展一下，假设Redis没有总是可用的保障。 Redlock算法在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁。我们确保将在每（N)个实例上使用此方法获取和释放锁。在这个样例中，我们假设有5个Redis master节点，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。 为了取到锁，客户端应该执行以下操作: 获取当前Unix时间，以毫秒为单位。 依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。 这个算法是异步的么?算法基于这样一个假设：虽然多个进程之间没有时钟同步，但每个进程都以相同的时钟频率前进，时间差相对于失效时间来说几乎可以忽略不计。这种假设和我们的真实世界非常接近：每个计算机都有一个本地时钟，我们可以容忍多个计算机之间有较小的时钟漂移。 从这点来说，我们必须再次强调我们的互相排斥规则：只有在锁的有效时间（在步骤3计算的结果）范围内客户端能够做完它的工作，锁的安全性才能得到保证（锁的实际有效时间通常要比设置的短，因为计算机之间有时钟漂移的现象）。 失败时重试当客户端无法取到锁时，应该在一个随机延迟后重试,防止多个客户端在同时抢夺同一资源的锁（这样会导致脑裂，没有人会取到锁）。同样，客户端取得大部分Redis实例锁所花费的时间越短，脑裂出现的概率就会越低（必要的重试），所以，理想情况一下，客户端应该同时（并发地）向所有Redis发送SET命令。 需要强调，当客户端从大多数Redis实例获取锁失败时，应该尽快地释放（部分）已经成功取到的锁，这样其他的客户端就不必非得等到锁过完“有效时间”才能取到（然而，如果已经存在网络分裂，客户端已经无法和Redis实例通信，此时就只能等待key的自动释放了，等于被惩罚了）。 释放锁释放锁比较简单，向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁. 安全争议这个算法安全么？我们可以从不同的场景讨论一下。 让我们假设客户端从大多数Redis实例取到了锁。所有的实例都包含同样的key，并且key的有效时间也一样。然而，key肯定是在不同的时间被设置上的，所以key的失效时间也不是精确的相同。我们假设第一个设置的key时间是T1(开始向第一个server发送命令前时间），最后一个设置的key时间是T2(得到最后一台server的答复后的时间），我们可以确认，第一个server的key至少会存活 MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT。所有其他的key的存活时间，都会比这个key时间晚，所以可以肯定，所有key的失效时间至少是MIN_VALIDITY。 当大部分实例的key被设置后，其他的客户端将不能再取到锁，因为至少N/2+1个实例已经存在key。所以，如果一个锁被（客户端）获取后，客户端自己也不能再次申请到锁(违反互相排斥属性）。 然而我们也想确保，当多个客户端同时抢夺一个锁时不能两个都成功。 如果客户端在获取到大多数redis实例锁，使用的时间接近或者已经大于失效时间，客户端将认为锁是失效的锁，并且将释放掉已经获取到的锁，所以我们只需要在有效时间范围内获取到大部分锁这种情况。在上面已经讨论过有争议的地方，在MIN_VALIDITY时间内，将没有客户端再次取得锁。所以只有一种情况，多个客户端会在相同时间取得N/2+1实例的锁，那就是取得锁的时间大于失效时间（TTL time)，这样取到的锁也是无效的. 如果你能提供关于现有的类似算法的一个正式证明（指出正确性），或者是发现这个算法的bug？ 我们将非常感激. 活性争议系统的活性安全基于三个主要特性: 锁的自动释放（因为key失效了）：最终锁可以再次被使用. 客户端通常会将没有获取到的锁删除，或者锁被取到后，使用完后，客户端会主动（提前）释放锁，而不是等到锁失效另外的客户端才能取到锁。. 当客户端重试获取锁时，需要等待一段时间，这个时间必须大于从大多数Redis实例成功获取锁使用的时间，以最大限度地避免脑裂。.然而，当网络出现问题时系统在失效时间(TTL)内就无法服务，这种情况下我们的程序就会为此付出代价。如果网络持续的有问题，可能就会出现死循环了。 这种情况发生在当客户端刚取到一个锁还没有来得及释放锁就被网络隔离.如果网络一直没有恢复，这个算法会导致系统不可用. 性能，崩溃恢复和Redis同步很多用户把Redis当做分布式锁服务器，使用获取锁和释放锁的响应时间，每秒钟可用执行多少次 acquire / release 操作作为性能指标。为了达到这一要求，增加Redis实例当然可用降低响应延迟（没有钱买硬件的”穷人”,也可以在网络方面做优化，使用非阻塞模型，一次发送所有的命令，然后异步的读取响应结果，假设客户端和redis服务器之间的RTT都差不多。 然而，如果我们想使用可以从备份中恢复的redis模式，有另外一种持久化情况你需要考虑，. 我们考虑这样一种场景，假设我们的redis没用使用备份。一个客户端获取到了3个实例的锁。此时，其中一个已经被客户端取到锁的redis实例被重启，在这个时间点，就可能出现3个节点没有设置锁，此时如果有另外一个客户端来设置锁，锁就可能被再次获取到，这样锁的互相排斥的特性就被破坏掉了。 如果我们启用了AOF持久化，情况会好很多。我们可用使用SHUTDOWN命令关闭然后再次重启。因为Redis到期是语义上实现的，所以当服务器关闭时，实际上还是经过了时间，所有（保持锁）需要的条件都没有受到影响. 没有受到影响的前提是redis优雅的关闭。停电了怎么办？如果redis是每秒执行一次fsync，那么很有可能在redis重启之后，key已经丢弃。理论上，如果我们想在Redis重启地任何情况下都保证锁的安全，我们必须开启fsync=always的配置。这反过来将完全破坏与传统上用于以安全的方式实现分布式锁的同一级别的CP系统的性能. 然而情况总比一开始想象的好一些。当一个redis节点重启后，只要它不参与到任意当前活动的锁，没有被当做“当前存活”节点被客户端重新获取到,算法的安全性仍然是有保障的。 为了达到这种效果，我们只需要将新的redis实例，在一个TTL时间内，对客户端不可用即可，在这个时间内，所有客户端锁将被失效或者自动释放. 使用延迟重启可以在不采用持久化策略的情况下达到同样的安全，然而这样做有时会让系统转化为彻底不可用。比如大部分的redis实例都崩溃了，系统在TTL时间内任何锁都将无法加锁成功。 使算法更加可靠：锁的扩展如果你的工作可以拆分为许多小步骤，可以将有效时间设置的小一些，使用锁的一些扩展机制。在工作进行的过程中，当发现锁剩下的有效时间很短时，可以再次向redis的所有实例发送一个Lua脚本，让key的有效时间延长一点（前提还是key存在并且value是之前设置的value)。 客户端扩展TTL时必须像首次取得锁一样在大多数实例上扩展成功才算再次取到锁，并且是在有效时间内再次取到锁（算法和获取锁是非常相似的）。 这样做从技术上将并不会改变算法的正确性，所以扩展锁的过程中仍然需要达到获取到N/2+1个实例这个要求，否则活性特性之一就会失效。]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务]]></title>
    <url>%2Fredis%2F2018%2F05%2F14%2Ftransactions%2F</url>
    <content type="text"><![CDATA[MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 EXEC 命令负责触发并执行事务中的所有命令： 如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。 另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。 当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。 然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。 如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。 使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。 从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。 用法MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。 另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。 以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：123456789&gt; MULTIOK&gt; INCR fooQUEUED&gt; INCR barQUEUED&gt; EXEC1) (integer) 12) (integer) 1 EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。 当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。 事务中的错误使用事务时可能会遇上以下两种错误： 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。 对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。 不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。 在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。 至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。 从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：1234567891011121314Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.MULTI+OKSET a 3abc+QUEUEDLPOP a+QUEUEDEXEC*2+OK-ERR Operation against a key holding the wrong kind of value EXEC 返回两条bulk-string-reply： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。 最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。 以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端： 1234MULTI+OKINCR a b c-ERR wrong number of arguments for &apos;incr&apos; command 因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。 为什么 Redis 不支持回滚（roll back）如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。 以下是这种做法的优点： Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 放弃事务当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：12345678910&gt; SET foo 1OK&gt; MULTIOK&gt; INCR fooQUEUED&gt; DISCARDOK&gt; GET foo&quot;1&quot; 使用 check-and-set 操作实现乐观锁WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。 举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。 首先我们可能会这样做：123val = GET mykeyval = val + 1SET mykey $val 上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。 有了 WATCH ， 我们就可以轻松地解决这类问题了：123456WATCH mykeyval = GET mykeyval = val + 1MULTISET mykey $valEXEC 使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。 这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。 了解 WATCHWATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。 了解更多-&gt; WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。 用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：12redis&gt; WATCH key1 key2 key3OK 当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。 另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。 使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。 使用 WATCH 实现 ZPOPWATCH 可以用于创建 Redis 没有内置的原子操作。举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：12345WATCH zsetelement = ZRANGE zset 0 0MULTIZREM zset elementEXEC 程序只要重复执行这段代码， 直到 EXEC 的返回值不是nil-reply回复即可。 Redis 脚本和事务从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。 因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。 不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。 不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。 Spring Boot 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;/** * 默认测试 */@Test@DisplayName("默认测试")void genericTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); List&lt;Object&gt; executeResult = stringRedisTemplate.execute((RedisCallback&lt;List&lt;Object&gt;&gt;) connection -&gt; &#123; // 开启事物 connection.multi(); String testKey = String.format("genericTestKey_%s", UUID.randomUUID().toString()); byte[] testKeySerializeBytes = keySerializer.serialize(testKey); byte[] defaultSerializeBytes = valueSerializer.serialize("1"); if (testKeySerializeBytes == null || defaultSerializeBytes == null) &#123; throw new BaseException("数据异常，无法操作"); &#125; try &#123; // 设置默认值：1 connection.set(testKeySerializeBytes, defaultSerializeBytes); // 给testKey incr 1 connection.incr(testKeySerializeBytes); &#125; finally &#123; // 删除testKey connection.del(testKeySerializeBytes); &#125; // 执行事物 return connection.exec(); &#125;); if (executeResult == null) &#123; throw new BaseException("执行结果为空，无法操作"); &#125; executeResult.forEach(o -&gt; logger.info("executeResult:&#123;&#125;", o));&#125;/** * 放弃事物 */@Test@DisplayName("discard")void discardTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123; String testKey = String.format("genericTestKey_%s", UUID.randomUUID().toString()); String defaultValue = "1"; byte[] testKeySerializeBytes = keySerializer.serialize(testKey); byte[] defaultSerializeBytes = valueSerializer.serialize(defaultValue); if (testKeySerializeBytes == null || defaultSerializeBytes == null) &#123; throw new BaseException("数据异常，无法操作"); &#125; try &#123; // 设置默认值：1 connection.set(testKeySerializeBytes, defaultSerializeBytes); logger.info("testKey set value is :&#123;&#125;", defaultValue); // 开启事物 connection.multi(); logger.info("multi "); // 给testKey incr 1 connection.incr(testKeySerializeBytes); logger.info("inrc testKey "); // 放弃事物 connection.discard(); logger.info("discard"); // 重新获得testKey的value byte[] nowTestKeyValueBytes = connection.get(testKeySerializeBytes); if (nowTestKeyValueBytes == null || nowTestKeyValueBytes.length == 0) &#123; throw new BaseException("无法获取testKey的value"); &#125; String nowTestKeyValue = new String(nowTestKeyValueBytes); logger.info("now testKey value is &#123;&#125;", nowTestKeyValue); &#125; finally &#123; // 删除testKey connection.del(testKeySerializeBytes); &#125; return null; &#125;);&#125;/** * 事物 不回滚测试 */@Test@DisplayName("noRollBackTest")void noRollBackTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123; String testKey = String.format("genericTestKey_%s", UUID.randomUUID().toString()); String defaultValue = "1"; byte[] testKeySerializeBytes = keySerializer.serialize(testKey); byte[] defaultSerializeBytes = valueSerializer.serialize(defaultValue); if (testKeySerializeBytes == null || defaultSerializeBytes == null) &#123; throw new BaseException("数据异常，无法操作"); &#125; try &#123; // 设置默认值：1 connection.set(testKeySerializeBytes, defaultSerializeBytes); logger.info("testKey set value is :&#123;&#125;", defaultValue); // 开启事物 connection.multi(); logger.info("multi "); // 给testKey incr 1 connection.incr(testKeySerializeBytes); logger.info("inrc testKey "); // 错误类型指令 connection.lPop(testKeySerializeBytes); logger.info("lPop testKey"); // 给testKey incr 1 connection.incr(testKeySerializeBytes); logger.info("inrc testKey "); // 提交之后虽然后异常，但是两次incr都成功执行了 RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123; logger.info("exec"); // 提交 List&lt;Object&gt; execResult = connection.exec(); execResult.forEach(o -&gt; logger.info("exec result:&#123;&#125;", o)); &#125;); logger.error("错误类型的命令异常",redisSystemException); // 重新获得testKey的value byte[] nowTestKeyValueBytes = connection.get(testKeySerializeBytes); if (nowTestKeyValueBytes == null || nowTestKeyValueBytes.length == 0) &#123; throw new BaseException("无法获取testKey的value"); &#125; String nowTestKeyValue = new String(nowTestKeyValueBytes); logger.info("now testKey value is &#123;&#125;", nowTestKeyValue); &#125; finally &#123; // 删除testKey connection.del(testKeySerializeBytes); &#125; return null; &#125;);&#125;]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将redis当做使用LRU算法的缓存来使用]]></title>
    <url>%2Fredis%2F2018%2F05%2F14%2Flru-cache%2F</url>
    <content type="text"><![CDATA[当Redis被当做缓存来使用，当你新增数据时，让它自动地回收旧数据是件很方便的事情。这个行为在开发者社区非常有名，因为它是memcached默认行为。 LRU是Redis唯一支持的回收方法。本页面包括一些常规话题，Redis的maxmemory指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU算法，这个实际上只是近似的LRU。 Maxmemory配置指令maxmemory配置指令用于配置Redis存储数据时指定限制的内存大小。通过redis.conf可以设置该指令，或者之后使用CONFIG SET命令来进行运行时配置。 例如为了配置内存限制为100mb，以下的指令可以放在redis.conf文件中。1maxmemory 100mb 设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB。 当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。 回收策略当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。 以下的策略是可用的: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 svolatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。 选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。 一般的经验规则: 使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。. 使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。 使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。 allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。 为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。 回收进程如何工作理解回收进程如何工作是非常重要的: 一个客户端运行了新的命令，添加了新的数据。 Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 近似LRU算法Redis的LRU算法并非完整的实现。这意味着Redis并没办法选择最佳候选来进行回收，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）。 不过从Redis 3.0算法已经改进为回收键的候选池子。这改善了算法的性能，使得更加近似真是的LRU算法的行为。 Redis LRU有个很重要的点，你通过调整每次回收时检查的采样数量，以实现调整算法的精度。这个参数可以通过以下的配置指令调整:1maxmemory-samples 5 在模拟实验的过程中，我们发现如果使用幂定律的访问模式，则真实的LRU算法和近似的Redis算法几乎没有差别。 当然你可以提升采样大小到10，消耗更多的CPU时间以实现更真实的LRU算法，同时查看下是否让你的缓存命中率有差别。 通过CONFIG SET maxmemory-samples 命令在生产环境上设置不同的采样大小是非常简单的。]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[expire]]></title>
    <url>%2Fredis%2F2018%2F05%2F10%2Fexpire%2F</url>
    <content type="text"><![CDATA[命令1EXPIRE key seconds 解释设置key的过期时间，超过时间后，将会自动删除该key。在Redis的术语中一个key的相关超时是不确定的。 超时后只有对key执行DEL命令或者SET命令或者GETSET时才会清除。 这意味着，从概念上讲所有改变key的值的操作都会使他清除。 例如，INCR递增key的值，执行LPUSH操作，或者用HSET改变hash的field所有这些操作都会触发删除动作。 使用PERSIST命令可以清除超时，使其变成一个永久的key。 如果key被RENAME命令修改，相关的超时时间会转移到新key上面。 如果key被RENAME命令修改，比如原来就存在Key_A,然后调用RENAME Key_B Key_A命令，这时不管原来Key_A是永久的还是设置为超时的，都会由Key_B的有效期状态覆盖。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值： Integers 1 如果成功设置过期时间。 0 如果key不存在或者不能设置过期时间。 刷新过期时间对已经有过期时间的key执行EXPIRE操作，将会更新它的过期时间。有很多应用有这种业务场景，例如记录会话的session。 1234567891011redis&gt; SET mykey "Hello"OKredis&gt; EXPIRE mykey 10(integer) 1redis&gt; TTL mykey(integer) 10redis&gt; SET mykey "Hello World"OKredis&gt; TTL mykey(integer) -1redis&gt; 案例: Navigation session想象一下，你有一个网络服务器，你对用户最近访问的N个网页感兴趣，每一个相邻的页面设置超时时间为60秒。在概念上你为这些网页添加Navigation session，如果你的用户，可能包含有趣的信息，他或她正在寻找什么样的产品，你可以推荐相关产品。 你可以使用下面的策略模型，使用这种模式：每次用户浏览网页调用下面的命令：1234MULTIRPUSH pagewviews.user:&lt;userid&gt; http://.....EXPIRE pagewviews.user:&lt;userid&gt; 60EXEC 附录: Redis 过期时间Keys的过期时间通常Redis keys创建时没有设置相关过期时间。他们会一直存在，除非使用显示的命令移除，例如，使用DEL命令。 EXPIRE一类命令能关联到一个有额外内存开销的key。当key执行过期操作时，Redis会确保按照规定时间删除他们。 key的过期时间和永久有效性可以通过EXPIRE和PERSIST命令（或者其他相关命令）来进行更新或者删除过期时间。 过期精度在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。 从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。 过期和持久Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。 要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（所有的 keys装载时就会过期）。 即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。 Redis如何淘汰过期的keysRedis keys过期有两种方式：被动和主动方式。 当一些客户端尝试访问它时，key会被发现并主动的过期。 当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。 具体就是Redis每秒10次做的事情： 测试随机的20个keys进行相关过期检测。 删除所有已经过期的keys。 如果有多于25%的keys过期，重复步奏1.这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。 在复制AOF文件时如何处理过期为了获得正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有附加的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。 然而，当slaves连接到master时，不会独立过期keys（会等到master执行DEL命令），他们任然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。 SpringBoot 测试用例123456789101112131415161718192021222324252627282930313233343536private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key存在时")void keyExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); String value = UUID.randomUUID().toString(); // SET testKey value stringRedisTemplate.opsForValue().set(testKey, value); logger.info("set testKey &#123;&#125;", value); // EXPIRE testKey 10 Boolean result = stringRedisTemplate.expire(testKey, 10, TimeUnit.SECONDS); logger.info("expire testKey result:&#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key不存在时")void keyNotExistTest() &#123; String testKey = String.format("testKey:%s", UUID.randomUUID().toString()); try &#123; logger.info("now random testKey is &#123;&#125;", testKey); // EXPIRE testKey 10 Boolean result = stringRedisTemplate.expire(testKey, 10, TimeUnit.SECONDS); logger.info("expire testKey result:&#123;&#125;", result); &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>keys</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存优化]]></title>
    <url>%2Fredis%2F2018%2F05%2F10%2Fmemory-optimization%2F</url>
    <content type="text"><![CDATA[小的聚合类型数据的特殊编码处理Redis2.2版本及以后，存储集合数据的时候会采用内存压缩技术，以使用更少的内存存储更多的数据。如Hashes,Lists,Sets和Sorted Sets，当这些集合中的所有数都小于一个给定的元素，并且集合中元素数量小于某个值时，存储的数据会被以一种非常节省内存的方式进行编码，使用这种编码理论上至少会节省10倍以上内存（平均节省5倍以上内存）。并且这种编码技术对用户和redis api透明。因为使用这种编码是用CPU换内存，所以我们提供了更改阈值的方法，只需在redis.conf里面进行修改即可.1234567hash-max-zipmap-entries 64 (2.6以上使用hash-max-ziplist-entries)hash-max-zipmap-value 512 (2.6以上使用hash-max-ziplist-value)list-max-ziplist-entries 512list-max-ziplist-value 64zset-max-ziplist-entries 128zset-max-ziplist-value 64set-max-intset-entries 512 （集合中）如果某个值超过了配置文件中设置的最大值，redis将自动把把它（集合）转换为正常的散列表。这种操作对于比较小的数值是非常快的，但是，如果你为了使用这种编码技术而把配置进行了更改，你最好做一下基准测试（和正常的不采用编码做一下对比）. 使用32位的redis使用32位的redis，对于每一个key,将使用更少的内存，因为32位程序，指针占用的字节数更少。但是32的redis整个实例使用的内存将被限制在4G以下。使用make 32bit命令编译生成32位的redis。RDB和AOF文件是不区分32位和64位的（包括字节顺序）,所以你可以使用64位的reidis恢复32位的RDB备份文件，相反亦然. 位级别和字级别的操作Redis 2.2引入了位级别和字级别的操作: GETRANGE, SETRANGE, GETBIT 和 SETBIT.使用这些命令，你可以把redis的字符串当做一个随机读取的（字节）数组。例如你有一个应用，用来标志用户的ID是连续的整数，你可以使用一个位图标记用户的性别，使用1表示男性，0表示女性，或者其他的方式。这样的话，1亿个用户将仅使用12 M的内存。你可以使用同样的方法，使用 GETRANGE 和 SETRANGE 命令为每个用户存储一个字节的信息。这仅是一个例子，实际上你可以使用这些原始数据类型解决更多问题。 尽可能使用散列表（hashes）小散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面. 如果你想了解更多关于这方面的知识，请读下一段. 使用散列结构高效存储抽象的键值对我知道这部分的标题很吓人，但是我将详细解释这部分内容. 一般而言，把一个模型（model）表示为key-value的形式存储在redis中非常容易，当然value必须为字符串，这样存储不仅比一般的key value存储高效，并且比memcached存储还高效. 让我们做个对比：一些key存储了一个对象的多个字段要比一个散列表存储对象的多个字段占用更多的内存。这怎么可能？从原理上讲，为了保证查找一个数据总是在一个常量时间内（O(1)）,需要一个常量时间复杂度的数据结构，比如说散列表. 但是，通常情况下，散列表只包括极少的几个字段。当散列表非常小的时候，我们采用将数据encode为一个O(N)的数据结构，你可以认为这是一个带有长度属性的线性数组。只有当N是比较小的时候，才会采用这种encode，这样使用HGET和HSET命令的复杂度仍然是O(1)：当散列表包含的元素增长太多的时候，散列表将被转换为正常的散列表（极限值可以在redis.conf进行配置）. 无论是从时间复杂度还是从常量时间的角度来看，采用这种encode理论上都不会有多大性能提升，但是，一个线性数组通常会被CPU的缓存更好的命中（线性数组有更好的局部性）,从而提升了访问的速度. 既然散列表的字段及其对应的值并不是用redis objects表示，所以散列表的字段不能像普通的key一样设置过期时间。但是这毫不影响对散列表的使用，因为散列表本来就是这样设计的（我们相信简洁比多功能更重要，所以嵌入对象是不允许的，散列表字段设置单独的过期时间是不允许的）. 所以散列表能高效利用内存。这非常有用,当你使用一个散列表存储一个对象或者抽象其他一类相关的字段为一个模型时。但是，如果我们有一个普通的key value业务需求怎么办? 假如我们想使用redis存储许多小对象，这些对象可以使用json字符串表示，也可能是HTML片段和简单的key-&gt;boolean键值对。概况的说，一切皆字符串，都可以使用string:string的形式表示. 我们假设要缓存的对象使用数字后缀进行编码，如: object:102393 object:1234 object:5 我们可以这样做。每次SET的时候，把key分为两部分，第一部分当做一个key，第二部当做散列表字段。比如“object:1234”,分成两部分: Key named object:12 Field named 34我们使用除最后2个数字的部分作为key,最后2个数字做为散列表的字段。使用命令:1HSET object:12 34 somevalue 如你所见，每个散列表将（理论上）包含100个字段，这是CPU资源和内存资源之间的一个折中. 另一个需要你关注的是在这种模式下，无论缓存多少对象，每个散列表都会分配100个字段。因为我们的对象总是以数字结尾，而不是一个随机的字符串。从某些方面来说，这是一种隐性的预分片。 对于小数字怎么处理？比如object:2,我们采用object:作为key,所有剩下的数字作为一个字段。所以object:2和object:10都会被存储到key为object:的散列表中，但是一个使用2作为字段，一个使用10作为字段。 这种方式将节省多少内存? 我使用了下面的Ruby程序进行了测试:123456789101112131415161718192021222324252627282930313233require 'rubygems'require 'redis'UseOptimization = truedef hash_get_key_field(key) s = key.split(":") if s[1].length &gt; 2 &#123;:key =&gt; s[0]+":"+s[1][0..-3], :field =&gt; s[1][-2..-1]&#125; else &#123;:key =&gt; s[0]+":", :field =&gt; s[1]&#125; endenddef hash_set(r,key,value) kf = hash_get_key_field(key) r.hset(kf[:key],kf[:field],value)enddef hash_get(r,key,value) kf = hash_get_key_field(key) r.hget(kf[:key],kf[:field],value)endr = Redis.new(0..100000).each&#123;|id| key = "object:#&#123;id&#125;" if UseOptimization hash_set(r,key,"val") else r.set(key,"val") end&#125; 在redis2.2的64位版本上测试结果: 当开启优化时使用内存1.7M 当未开启优化时使用内存11M从结果看出，这是一个数量级的优化，我认为这种优化使redis成为最出色的键值缓存。 特别提示: 要使上面的程序较好的工作，别忘记设置你的redis:1hash-max-zipmap-entries 256 相应的最大键值长度设置:1hash-max-zipmap-value 1024 每次散列表的元素数量或者值超过了阈值，散列将被扩展为一张真正的散列表进行存储，此时节约存储的优势就没有了. 或许你想问，你为什么不自动将这些key进行转化以提高内存利用率？有两个原因：第一是因为我们更倾向于让这些权衡明确，而且必须在很多事情之间权衡：CPU，内存，最大元素大小限制。第二是顶级的键空间支持很多有趣的特性，比如过期，LRU算法，所以这种做法并不是一种通用的方法. Redis的一贯风格是用户必须理解它是如何运作的，必须能够做出最好的选择和权衡，并且清楚它精确的运行方式.]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval]]></title>
    <url>%2Fredis%2F2018%2F05%2F09%2Feval%2F</url>
    <content type="text"><![CDATA[EVAL script numkeys key [key …] arg [arg …]解释EVAL 和 EVALSHA 命令是从 Redis 2.6.0 版本开始的，使用内置的 Lua 解释器，可以对 Lua 脚本进行求值。 EVAL的第一个参数是一段 Lua 5.1 脚本程序。 这段Lua脚本不需要（也不应该）定义函数。它运行在 Redis 服务器中。 EVAL的第二个参数是参数的个数，后面的参数（从第三个参数），表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。 在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。 举例说明：12345&gt; eval &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second1) &quot;key1&quot;2) &quot;key2&quot;3) &quot;first&quot;4) &quot;second&quot; 注：返回结果是Redis multi bulk replies的Lua数组，这是一个Redis的返回类型，您的客户端库可能会将他们转换成数组类型。 这是从一个Lua脚本中使用两个不同的Lua函数来调用Redis的命令的例子：12redis.call()redis.pcall() redis.call() 与 redis.pcall()很类似, 他们唯一的区别是当redis命令执行结果返回错误时， redis.call()将返回给调用者一个错误，而redis.pcall()会将捕获的错误以Lua表的形式返回 redis.call() 和 redis.pcall() 两个函数的参数可以是任意的 Redis 命令：12&gt; eval "return redis.call('set','foo','bar')" 0OK 需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：12&gt; eval "return redis.call('set',KEYS[1],'bar')" 1 fooOK 要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。 因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。 除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。 (对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的， 从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。 Lua 脚本能返回一个值，这个值能按照一组转换规则从Lua转换成redis的返回类型。 Lua 数据类型和 Redis 数据类型之间转换当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。 同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。 数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。 换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。 Redis 到 Lua 的转换表。 Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字 Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串 Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型 Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 ok 域包含了状态信息 Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 err 域包含了错误信息 Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 false Lua 到 Redis 的转换表。 Lua number -&gt; Redis integer reply (the number is converted into an integer) / Lua 数字转换成 Redis 整数 Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复 Lua table (array) -&gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any) / Lua 表(数组)转换成 Redis 多条 bulk 回复 Lua table with a single ok field -&gt; Redis status reply / 一个带单个 ok 域的 Lua 表，转换成 Redis 状态回复 Lua table with a single err field -&gt; Redis error reply / 一个带单个 err 域的 Lua 表，转换成 Redis 错误回复 Lua boolean false -&gt; Redis Nil bulk reply. / Lua 的布尔值 false 转换成 Redis 的 Nil bulk 回复从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则： Lua boolean true -&gt; Redis integer reply with value of 1. / Lua 布尔值 true 转换成 Redis 整数回复中的 1 还有下面两点需要重点注意： lua中整数和浮点数之间没有什么区别。因此，我们始终Lua的数字转换成整数的回复，这样将舍去小数部分。如果你想从Lua返回一个浮点数，你应该将它作为一个字符串（见比如ZSCORE命令）。 There is no simple way to have nils inside Lua arrays, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered. 以下是几个类型转换的例子：1234567891011&gt; eval "return 10" 0(integer) 10&gt; eval "return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;" 01) (integer) 12) (integer) 23) 1) (integer) 3 2) "Hello World!"&gt; eval "return redis.call('get','foo')" 0"bar" 最后一个例子展示如果是Lua直接命令调用它是如何可以从redis.call()或redis.pcall()接收到准确的返回值。 下面的例子我们可以看到浮点数和nil将怎么样处理：12345&gt; eval "return &#123;1,2,3.3333,'foo',nil,'bar'&#125;" 01) (integer) 12) (integer) 23) (integer) 34) "foo" 正如你看到的 3.333 被转换成了3，并且 nil后面的字符串bar没有被返回回来。 返回redis类型的辅助函数有两个辅助函数从Lua返回Redis的类型。 redis.error_reply(error_string) returns an error reply. This function simply returns the single field table with the err field set to the specified string for you. redis.status_reply(status_string) returns a status reply. This function simply returns the single field table with the ok field set to the specified string for you. There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent: 12return &#123;err="My Error"&#125;return redis.error_reply("My Error") 脚本的原子性Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。 这和使用 MULTI / EXEC 包围的事务很类似。 在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。 另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难， 因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心， 因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。 错误处理前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。 当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：123456&gt; del foo(integer) 1&gt; lpush foo a(integer) 1&gt; eval "return redis.call('get','foo')" 0(error) ERR Error running script (call to f_6b1bf486c81ceb7edf3c093f4c48582e38c0e791): ERR Operation against a key holding the wrong kind of value 和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：12redis 127.0.0.1:6379&gt; EVAL "return redis.pcall('get', 'foo')" 0(error) ERR Operation against a key holding the wrong kind of value 带宽和 EVALSHAEVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。 为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。 EVALSHA 命令的表现如下： 如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本 如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA 以下是示例：1234567891011&gt; set foo barOK&gt; eval "return redis.call('get','foo')" 0"bar"&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0"bar"&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/eval). 客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。 这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗 脚本缓存Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。 刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。 缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。 事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。 SCRIPT 命令Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制： SCRIPT FLUSH ：清除所有脚本缓存 SCRIPT EXISTS ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存 SCRIPT LOAD ：将一个脚本装入脚本缓存，但并不立即运行它 SCRIPT KILL ：杀死当前正在运行的脚本 纯函数脚本在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。 也就是说，脚本应该具有以下属性： 对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。 使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。 为了确保脚本符合上面所说的属性， Redis 做了以下工作： Lua 没有访问系统时间或者其他内部状态的命令 Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 RANDOMKEY 、 SRANDMEMBER 或 TIME 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 TIME 命令就是这方面的一个很好的例子。 每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(lexicographical sorting)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 SMEMBERS ，返回的元素是无序的，但是，假如在脚本中执行 redis.call(“smembers”, KEYS[1]) ，那么返回的总是排过序的元素。 对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 math.randomseed ，那么 math.random 产生的随机数序列总是相同的。尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。 假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：1234567891011121314151617require 'rubygems'require 'redis'r = Redis.newRandomPushScript = &lt;&lt;EOF local i = tonumber(ARGV[1]) local res while (i &gt; 0) do res = redis.call('lpush',KEYS[1],math.random()) i = i-1 end return resEOFr.del(:mylist)puts r.eval(RandomPushScript,[:mylist],[10,rand(2**32)]) 这个程序每次运行都会生成带有以下元素的列表：1234567891011&gt; lrange mylist 0 -11) "0.74509509873814"2) "0.87390407681181"3) "0.36876626981831"4) "0.6921941534114"5) "0.7857992587545"6) "0.57730350670279"7) "0.87046522734243"8) "0.09637165539729"9) "0.74990198051087"10) "0.17082803611217" 上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。 以下是修改后的脚本：12345678910111213RandomPushScript = &lt;&lt;EOF local i = tonumber(ARGV[1]) local res math.randomseed(tonumber(ARGV[2])) while (i &gt; 0) do res = redis.call('lpush',KEYS[1],math.random()) i = i-1 end return resEOFr.del(:mylist)puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32)) 尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。 Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。 注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。 全局变量保护为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。 企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：12redis 127.0.0.1:6379&gt; eval &apos;a=10&apos; 0(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable &apos;a&apos; Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。 实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。 避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。 使用选择内部脚本在正常的客户端连接里面可以调用SELECT选择内部的Lua脚本，但是Redis 2.8.11和Redis 2.8.12在行为上有一个微妙的变化。在2.8.12之前，会将脚本传送到调用脚本的当前数据库。从2.8.12开始Lua脚本只影响脚本本身的执行，但不修改当前客户端调用脚本时选定的数据库。 从补丁级发布的语义变化是必要的，因为旧的行为与Redis复制层固有的不相容是错误的原因。 可用库Redis Lua解释器可用加载以下Lua库： base lib. table lib. string lib. math lib. debug lib. struct lib. cjson lib. cmsgpack lib. bitop lib. redis.sha1hex function. 每一个Redis实例都拥有以上的所有类库，以确保您使用脚本的环境都是一样的。 struct, CJSON 和 cmsgpack 都是外部库, 所有其他库都是标准。 Lua库。 struct 库struct 是一个Lua装箱/拆箱的库1234567891011121314151617Valid formats:&gt; - big endian&lt; - little endian![num] - alignmentx - padingb/B - signed/unsigned byteh/H - signed/unsigned shortl/L - signed/unsigned longT - size_ti/In - signed/unsigned integer with size `n&apos; (default is size of int)cn - sequence of `n&apos; chars (from/to a string); when packing, n==0 means the whole string; when unpacking, n==0 means use the previous read number as the string lengths - zero-terminated stringf - floatd - double&apos; &apos; - ignored 例子：12345678127.0.0.1:6379&gt; eval 'return struct.pack("HH", 1, 2)' 0"\x01\x00\x02\x00"127.0.0.1:6379&gt; eval 'return &#123;struct.unpack("HH", ARGV[1])&#125;' 0 "\x01\x00\x02\x00"1) (integer) 12) (integer) 23) (integer) 5127.0.0.1:6379&gt; eval 'return struct.size("HH")' 0(integer) 4 CJSON 库CJSON 库为Lua提供极快的JSON处理 例子：1234redis 127.0.0.1:6379&gt; eval 'return cjson.encode(&#123;["foo"]= "bar"&#125;)' 0"&#123;\"foo\":\"bar\"&#125;"redis 127.0.0.1:6379&gt; eval 'return cjson.decode(ARGV[1])["foo"]' 0 "&#123;\"foo\":\"bar\"&#125;""bar" cmsgpack 库cmsgpack 库为Lua提供了简单、快速的MessagePack操纵 例子：123456127.0.0.1:6379&gt; eval 'return cmsgpack.pack(&#123;"foo", "bar", "baz"&#125;)' 0"\x93\xa3foo\xa3bar\xa3baz"127.0.0.1:6379&gt; eval 'return cmsgpack.unpack(ARGV[1])' 0 "\x93\xa3foo\xa3bar\xa3baz"1) "foo"2) "bar"3) "baz" bitop 库bitop库为Lua的位运算模块增加了按位操作数。 它是Redis 2.8.18开始加入的。 例子：123456127.0.0.1:6379&gt; eval 'return bit.tobit(1)' 0(integer) 1127.0.0.1:6379&gt; eval 'return bit.bor(1,2,4,8,16,32,64,128)' 0(integer) 255127.0.0.1:6379&gt; eval 'return bit.tohex(422342)' 0"000671c6" 它支持几个其他功能： bit.tobit bit.tohex bit.bnot bit.band bit.bor bit.bxor bit.lshift bit.rshift bit.arshift bit.rol bit.ror bit.bswap redis.sha1hex对字符串执行SHA1算法 例子：12127.0.0.1:6379&gt; eval 'return redis.sha1hex(ARGV[1])' 0 "foo""0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33" 使用脚本记录 Redis 日志在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：1redis.log(loglevel,message) 其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值： redis.LOG_DEBUG redis.LOG_VERBOSE redis.LOG_NOTICE redis.LOG_WARNING 上面的这些等级(level)和标准 Redis 日志的等级相对应。 对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。 以下是一个日志示例：1redis.log(redis.LOG_WARNING, "Something is wrong with this script.") 执行上面的函数会产生这样的信息：1[32343] 22 Mar 15:21:39 # Something is wrong with this script. 沙箱(sandbox)和最大执行时间脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。 除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。 最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET 和 CONFIG SET 命令来修改它。 当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。 因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行： Redis 记录一个脚本正在超时运行 Redis 开始重新接受其他客户端的命令请求，但是只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 BUSY 错误。 可以使用 SCRIPT KILL 命令将一个仅执行只读命令的脚本杀死，因为- - 只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性如果脚本已经执行过写命令，那么唯一允许执行的操作就是 SHUTDOWN NOSAVE ，它通过停止服务器来阻止当前数据集写入磁盘 流水线(pipeline)上下文(context)中的 EVALSHA在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。 一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。 为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施： 总是在流水线中使用 EVAL 命令 检查流水线中要用到的所有命令，找到其中的 EVAL 命令，并使用 SCRIPT EXISTS 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 EVAL 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 SCRIPT LOAD 命令加上去。 Spring Boot 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("脚本参数测试")void paramsTest() &#123; List resultList = stringRedisTemplate.execute(new RedisScript&lt;List&gt;() &#123; /** * 返回脚本的sha1加密值 * 避免重复传递脚本带来的性能损耗 * Redis提供了一组命令： * SCRIPT LOAD 脚本 把脚本加载进Redis缓存中 * SCRIPT EXIST sha1值 判断sha1是否存在于Redis缓存 * EVALSHA sha1值 参数 通过sha1的方式云效指定的脚本 * 本方法的作用主要是提供Redis脚本sha1后的值 * @return 脚本sha1后的加密值 */ @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; /** * 脚本发返回值的Class实例 * @return 返回值的Class实例 */ @Override public Class&lt;List&gt; getResultType() &#123; return List.class; &#125; /** * 脚本 * @return 脚本 */ @Override public String getScriptAsString() &#123; return "return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"; &#125; &#125;, Arrays.asList("key1", "key2"), "arg1", "arg2"); Assertions.assertNotNull(resultList); for (Object result : resultList) &#123; logger.info("paramsTest,result:&#123;&#125;", result); &#125;&#125;@Test@DisplayName("返回数字测试")void returnNumberTest() &#123; // 这个地方有个坑，就是返回的数字没法包含小数 // 如果要返回小数则需要在脚本里面转为string类型 // 然后返回值用String接收 Number result = stringRedisTemplate.execute(new RedisScript&lt;Number&gt;() &#123; @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; @Override public Class&lt;Number&gt; getResultType() &#123; return Number.class; &#125; @Override public String getScriptAsString() &#123; return "return 234.567"; &#125; &#125;, Collections.singletonList("key1")); Assertions.assertNotNull(result); logger.info("result:&#123;&#125;", result);&#125;@Test@DisplayName("返回布尔值")void returnBooleanTest() &#123; Boolean result = stringRedisTemplate.execute(new RedisScript&lt;Boolean&gt;() &#123; @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; @Override public Class&lt;Boolean&gt; getResultType() &#123; return Boolean.class; &#125; @Override public String getScriptAsString() &#123; return "return true"; &#125; &#125;, Collections.singletonList("key1")); logger.info("result:&#123;&#125;", result);&#125;@Test@DisplayName("错误处理-redis.call")void errorTestByCall() &#123; // 虽然call 和 pcall测试用例都抛出了异常 // 但是从运行结果上来看，可以发现 // pcall 和call 最大的区别就是call会中断脚本的执行 // 而pcall 只会在方法的返回值上返回一个错误信息 ListOperations&lt;String, String&gt; stringStringListOperations = stringRedisTemplate.opsForList(); String testKey = String.format("errorTestByCall_%s", UUID.randomUUID().toString()); try &#123; stringStringListOperations.leftPush(testKey, UUID.randomUUID().toString()); RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123; Object result = stringRedisTemplate.execute(new RedisScript&lt;Object&gt;() &#123; @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; @Override public Class&lt;Object&gt; getResultType() &#123; return Object.class; &#125; @Override public String getScriptAsString() &#123; return "redis.call('get',KEYS[1])\n" + "redis.call('lpush ',KEYS[1],KEYS[1])"; &#125; &#125;, Collections.singletonList(testKey)); logger.info("result:&#123;&#125;", result); &#125;); logger.error("error", redisSystemException); while (true) &#123; String leftPop = stringStringListOperations.leftPop(testKey); if (StringUtils.isBlank(leftPop)) &#123; break; &#125; logger.info("leftPop:&#123;&#125;", leftPop); &#125; &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("错误处理-redis.pcall")void errorTestByPCall() &#123; // 虽然call 和 pcall测试用例都抛出了异常 // 但是从运行结果上来看，可以发现 // pcall 和call 最大的区别就是call会中断脚本的执行 // 而pcall 只会在方法的返回值上返回一个错误信息 ListOperations&lt;String, String&gt; stringStringListOperations = stringRedisTemplate.opsForList(); String testKey = String.format("errorTestByPCall_%s", UUID.randomUUID().toString()); try &#123; stringStringListOperations.leftPush(testKey, UUID.randomUUID().toString()); RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, () -&gt; &#123; Object result = stringRedisTemplate.execute(new RedisScript&lt;Object&gt;() &#123; @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; @Override public Class&lt;Object&gt; getResultType() &#123; return Object.class; &#125; @Override public String getScriptAsString() &#123; return "local error = redis.pcall('get',KEYS[1])\n" + "redis.pcall('lpush',KEYS[1],KEYS[1])\n" + "return error"; &#125; &#125;, Collections.singletonList(testKey)); logger.info("result:&#123;&#125;", result); &#125;); logger.error("error", redisSystemException); while (true) &#123; String leftPop = stringStringListOperations.leftPop(testKey); if (StringUtils.isBlank(leftPop)) &#123; break; &#125; logger.info("leftPop:&#123;&#125;", leftPop); &#125; &#125; finally &#123; stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("返回复杂的数据")void returnManyValue() &#123; List resultList = stringRedisTemplate.execute(new RedisScript&lt;List&gt;() &#123; @Override public String getSha1() &#123; return DigestUtils.sha1DigestAsHex(getScriptAsString()); &#125; @Override public Class&lt;List&gt; getResultType() &#123; return List.class; &#125; @Override public String getScriptAsString() &#123; return "return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"; &#125; &#125;, Collections.singletonList("testKey")); Assertions.assertNotNull(resultList); for (Object obj : resultList) &#123; logger.info("obj[&#123;&#125;]:&#123;&#125;", obj.getClass().getSimpleName(), obj); if (obj instanceof List) &#123; List childObjList = (List) obj; for (Object childObj : childObjList) &#123; logger.info("childObj[&#123;&#125;]:&#123;&#125;", childObj.getClass().getSimpleName(), childObj); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>script</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管道（Pipelining）]]></title>
    <url>%2Fredis%2F2018%2F05%2F09%2Fpipelining%2F</url>
    <content type="text"><![CDATA[请求/响应协议和RTTRedis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。 这意味着通常情况下一个请求会遵循以下步骤： 客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。因此，例如下面是4个命令序列执行情况：12345678Client: INCR XServer: 1Client: INCR XServer: 2Client: INCR XServer: 3Client: INCR XServer: 4 客户端和服务器通过网络进行连接。这个连接可以很快（loopback接口）或很慢（建立了一个多次跳转的网络连接）。无论网络延如何延时，数据包总是能从客户端到达服务器，并从服务器返回数据回复客户端。 这个时间被称之为 RTT (Round Trip Time - 往返时间). 当客户端需要在一个批处理中执行多次请求时很容易看到这是如何影响性能的（例如添加许多元素到同一个list，或者用很多Keys填充数据库）。例如，如果RTT时间是250毫秒（在一个很慢的连接下），即使服务器每秒能处理100k的请求数，我们每秒最多也只能处理4个请求。 如果采用loopback接口，RTT就短得多（比如我的主机ping 127.0.0.1只需要44毫秒），但它任然是一笔很多的开销在一次批量写入操作中。 幸运的是有一种方法可以改善这种情况。 Redis 管道（Pipelining）一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。 Redis很早就支持管道（pipelining）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作Redis。下面是一个使用的例子：1234$ (printf "PING\r\nPING\r\nPING\r\n"; sleep 1) | nc localhost 6379+PONG+PONG+PONG 这一次我们没有为每个命令都花费了RTT开销，而是只用了一个命令的开销时间。 非常明确的，用管道顺序操作的第一个例子如下：12345678Client: INCR XClient: INCR XClient: INCR XClient: INCR XServer: 1Server: 2Server: 3Server: 4 重要说明使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。 这不仅仅是RTT的问题不仅仅是为了减少往返时间所带来的延迟成本，它实际上可以提高您在给定的Redis服务器上每秒执行的总操作量。这是事实的结果，即在不使用管道的情况下，从访问数据结构和生成答复的角度来看，每个命令的消耗都非常低，但从调用的Socket I/O角度来看. 这涉及read()和write()的系统调用，意味着需要从用户空间到内核的空间不断的切换，而上下文切换会有巨大的消耗。 当使用管道时，多个命令通常只用一次read()来从Socket IO读取出来，而多次响应则通过一次write()系统调用来传递。因此，Redis每秒执行查询速率会随着随着较长的管道提高，并最终达到未使用管道情况的10倍 Ruby例子在以下基准测试中，我们将使用支持流水线的Redis Ruby客户端来测试由于流水线而导致的速度提升：12345678910111213141516171819202122232425262728293031require 'rubygems'require 'redis'def bench(descr) start = Time.now yield puts "#&#123;descr&#125; #&#123;Time.now-start&#125; seconds"enddef without_pipelining r = Redis.new 10000.times &#123; r.ping &#125;enddef with_pipelining r = Redis.new r.pipelined &#123; 10000.times &#123; r.ping &#125; &#125;endbench("without pipelining") &#123; without_pipelining&#125;bench("with pipelining") &#123; with_pipelining&#125; 运行上述简单脚本将在我的Mac OS X系统中提供以下图形，通过环回接口运行，其中流水线将提供最小的改进，因为RTT已经非常低：12without pipelining 1.185238 secondswith pipelining 0.250783 seconds 正如您所看到的，使用流水线，我们将传输改进了五倍。 Spring Boot 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("批量GET测试")void batchGetTest() &#123; // 测试的key String testKey = String.format("keyNotExistTest_%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("编码testKey失败"); &#125; try &#123; // testKey对应的原始值 String originalValue = "a"; logger.info("testKey is &#123;&#125;", testKey); // 设置testKey一个值，因此testKey会存在与redis stringRedisTemplate.opsForValue().set(testKey, originalValue); logger.info("testKey set value is &#123;&#125;,so the key is exist in redis", originalValue); List&lt;Object&gt; resultList = stringRedisTemplate.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; connection.get(testKeySerializeBytes); &#125; // 在Pipeline情况下只能返回NULL // 毕竟是有点异步的意思，不能立马获得命令的结果的 return null; &#125;); resultList.forEach(o -&gt; logger.info("pipeline result is &#123;&#125;", o)); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("批量SET")void batchSetTest() &#123; @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") RedisSerializer&lt;String&gt; valueSerializer = (RedisSerializer&lt;String&gt;) stringRedisTemplate.getValueSerializer(); List&lt;String&gt; testKeyList = new ArrayList&lt;&gt;(); try &#123; List&lt;Object&gt; resultList = stringRedisTemplate.executePipelined((RedisCallback&lt;Object&gt;) connection -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; // 测试的key String testKey = String.format("batchSetTest_%s", UUID.randomUUID().toString()); testKeyList.add(testKey); // testKey对应的原始值 String value = UUID.randomUUID().toString(); logger.info("testKey is &#123;&#125;", testKey); final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("编码testKey失败"); &#125; final byte[] valueSerializeBytes = valueSerializer.serialize(value); if (valueSerializeBytes == null) &#123; throw new BaseException("编码testKey失败"); &#125; connection.set(testKeySerializeBytes, valueSerializeBytes); &#125; // 在Pipeline情况下只能返回NULL // 毕竟是有点异步的意思，不能立马获得命令的结果的 return null; &#125;); resultList.forEach(o -&gt; logger.info("pipeline result is &#123;&#125;", o)); testKeyList.forEach(testKey -&gt; &#123; String value = stringRedisTemplate.opsForValue().get(testKey); logger.info("after pipeline get testKey:&#123;&#125;,value is &#123;&#125;", testKey, value); &#125;); &#125; finally &#123; stringRedisTemplate.delete(testKeyList); &#125;&#125; 流水线VS脚本使用Redis脚本（Redis版本2.6或更高版本中可用），可以使用执行服务器端所需大量工作的脚本更高效地处理大量流水线用例。脚本的一大优点是它能够以最小的延迟读取和写入数据，使得读取，计算，写入等操作非常快速（在这种情况下流水线操作无法提供帮助，因为客户端需要先读取命令的回复它可以调用写命令）。 简单理解，就是单一的批量操作，适合用用管道方式如果遇到下一个命令参数是上一个命令的结果构成，那适合脚本方式 有时，应用程序可能还想在管道中发送EVAL或EVALSHA命令。这是完全可能的，并且Redis通过SCRIPT LOAD命令明确支持它（它保证可以在没有失败风险的情况下调用EVALSHA）。 附录：为什么即使在本地回环接口上，一个繁忙的循环也很慢？即使在本页面介绍的所有背景下，您仍然可能仍然想知道为什么如下所示的Redis基准测试（在伪代码中），即使在回环接口中执行时，服务器和客户端在同一物理机器上运行时，也很慢：123FOR-ONE-SECOND: Redis.SET(&quot;foo&quot;,&quot;bar&quot;)END 毕竟，如果Redis进程和基准测试都在同一个机器上运行，那么这不仅仅是通过内存从一个地方复制到另一个地方，而没有任何实际的延迟和实际网络？ 原因是系统中的进程并不总是在运行，实际上它是让进程运行的内核调度器，所以会发生什么，例如，允许基准运行，从Redis服务器读取回复（相关到执行的最后一个命令），并写入一个新的命令。该命令现在位于回环接口缓冲区中，但为了被服务器读取，内核应该安排服务器进程（当前在系统调用中阻塞）运行，等等。因此，实际上，由于内核调度程序的工作原理，回送接口仍然涉及网络延迟。 基本上，一个繁忙的循环基准测试是在网络服务器中测量性能时可以完成的最难的事情。明智的做法是以这种方式避免基准测试。]]></content>
      <tags>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DECR]]></title>
    <url>%2Fredis%2F2018%2F05%2F08%2FDECR%2F</url>
    <content type="text"><![CDATA[DECR key解释对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。 扩展 支持版本: &gt;= 1.0.0 时间复杂度: O(1) 返回值: Integers,减小之后的value redis-cli 例子12345678910redis&gt; SET mykey "10"OKredis&gt; DECR mykey(integer) 9redis&gt; SET mykey "234293482390480948029348230948"OKredis&gt; DECR mykeyERR value is not an integer or out of rangeredis&gt; DEL mykey(integer) 1 Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("testKey不存在的情况")void testKeyNotExist() &#123; // 测试的key String testKey = String.format("keyNotExistTest_%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("序列化testKey失败"); &#125; try &#123; logger.info("testKey is &#123;&#125;,the testKey is a random key ,so it not exist in redis", testKey); Long decreaseReturn = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null) &#123; throw new BaseException("无法连接redis"); &#125; return connection.decr(testKeySerializeBytes); &#125; &#125;); logger.info("testKey decr is ok and result is &#123;&#125;", decreaseReturn); String value = stringRedisTemplate.opsForValue().get(testKey); logger.info("after decr,value is:&#123;&#125;", value); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("testKey存在的情况")void testKeyExist() &#123; // 测试Key String testKey = String.format("keyExistTest_%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("序列化testKey失败"); &#125; try &#123; // testKey对应的原始值 String originalValue = "1234"; logger.info("testKey is &#123;&#125;", testKey); ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue(); // 设置testKey一个值，因此testKey会存在与redis stringStringValueOperations.set(testKey, originalValue); logger.info("testKey set value is &#123;&#125;,so the key is exist in redis", originalValue); // 在testKey存在的情况下append Long decreaseValueReturn = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null) &#123; throw new BaseException("链接Redis失败"); &#125; return connection.decr(testKeySerializeBytes); &#125; &#125;); logger.info("testKey decr ok and result is &#123;&#125;", decreaseValueReturn); // 重新获取testKey的值 String newValue = stringStringValueOperations.get(testKey); logger.info("after decr testKey`s value is &#123;&#125;", newValue); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("value不是数字情况下")void valueNotNumber() &#123; // 测试Key String testKey = String.format("valueNotNumber_%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); if (testKeySerializeBytes == null) &#123; throw new BaseException("序列化testKey失败"); &#125; try &#123; // testKey对应的原始值 String originalValue = "abc"; logger.info("testKey is &#123;&#125;", testKey); ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue(); // 设置testKey一个值，因此testKey会存在与redis stringStringValueOperations.set(testKey, originalValue); logger.info("testKey set value is &#123;&#125;,so the key is exist in redis", originalValue); RedisSystemException redisSystemException = Assertions.assertThrows(RedisSystemException.class, new Executable() &#123; @Override public void execute() throws Throwable &#123; // 在testKey存在的情况下decr Long decreaseValueReturn = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null) &#123; throw new BaseException("链接Redis失败"); &#125; return connection.decr(testKeySerializeBytes); &#125; &#125;); logger.info("testKey decr ok and result is &#123;&#125;", decreaseValueReturn); &#125; &#125;); logger.error("now is decr key value is not number exception", redisSystemException); // 重新获取testKey的值 String newValue = stringStringValueOperations.get(testKey); logger.info("after decr testKey`s value is &#123;&#125;", newValue); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BITPOS]]></title>
    <url>%2Fredis%2F2018%2F05%2F08%2FBITPOS%2F</url>
    <content type="text"><![CDATA[BITPOS key bit [start] [end]解释返回字符串里面第一个被设置为1或者0的bit位。 返回一个位置，把字符串当做一个从左到右的字节数组，第一个符合条件的在位置0，其次在位置8，等等。 GETBIT 和 SETBIT 相似的也是操作字节位的命令。 默认情况下整个字符串都会被检索一次，只有在指定start和end参数(指定start和end位是可行的)，该范围被解释为一个字节的范围，而不是一系列的位。所以start=0 并且 end=2是指前三个字节范围内查找。 注意，返回的位的位置始终是从0开始的，即使使用了start来指定了一个开始字节也是这样。 和GETRANGE命令一样，start和end也可以包含负值，负值将从字符串的末尾开始计算，-1是字符串的最后一个字节，-2是倒数第二个，等等。 不存在的key将会被当做空字符串来处理。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(N) 返回值: 命令返回字符串里面第一个被设置为1或者0的bit位。如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。如果我们在字符串里面查找bit为0而且字符串只包含1的值时，将返回字符串最右边的第一个空位。如果有一个字符串是三个字节的值为0xff的字符串，那么命令BITPOS key 0将会返回24，因为0-23位都是1。基本上，我们可以把字符串看成右边有无数个0。然而，如果你用指定start和end范围进行查找指定值时，如果该范围内没有对应值，结果将返回-1。 redis-cli 例子123456789101112131415redis&gt; SET mykey "\xff\xf0\x00"OKredis&gt; BITPOS mykey 0 # 查找字符串里面bit值为0的位置(integer) 12redis&gt; SET mykey "\x00\xff\xf0"OKredis&gt; BITPOS mykey 1 0 # 查找字符串里面bit值为1从第0个字节开始的位置(integer) 8redis&gt; BITPOS mykey 1 2 # 查找字符串里面bit值为1从第2个字节(12)开始的位置(integer) 16redis&gt; set mykey "\x00\x00\x00"OKredis&gt; BITPOS mykey 1 # 查找字符串里面bit值为1的位置(integer) -1redis&gt;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BITOP]]></title>
    <url>%2Fredis%2F2018%2F05%2F08%2FBITOP%2F</url>
    <content type="text"><![CDATA[BITOP operation destkey key [key …]s解释对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数： BITOP AND destkey srckey1 srckey2 srckey3 … srckeyN ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITOP OR destkey srckey1 srckey2 srckey3 … srckeyN，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 BITOP XOR destkey srckey1 srckey2 srckey3 … srckeyN，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 BITOP NOT destkey srckey，对给定 key 求逻辑非，并将结果保存到 destkey 。 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。执行结果将始终保持到destkey里面。 处理不同长度的字符串当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(N) 返回值: Integers,保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。 redis-cli 例子123456789redis&gt; SET key1 "foobar"OKredis&gt; SET key2 "abcdef"OKredis&gt; BITOP AND dest key1 key2(integer) 6redis&gt; GET dest"`bc`ab"redis&gt;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BITFIELD]]></title>
    <url>%2Fredis%2F2018%2F05%2F08%2FBITFIELD%2F</url>
    <content type="text"><![CDATA[BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]解释本命令会把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。 扩展 支持版本: &gt;= 3.2.0 时间复杂度: O(1) for each subcommand specified 已支持的命令列表 GET – 返回指定的位域 SET – 设置指定位域的值并返回它的原值 INCRBY – 自增或自减（如果increment为负数）指定位域的值并返回它的新值 OVERFLOW [WRAP|SAT|FAIL] 通过设置溢出处理方式来改变调用INCRBY指令的后溢出的结果 当需要一个整型时，有符号整型需在位数前加i，无符号在位数前加u。例如，u8是一个8位的无符号整型，i16是一个16位的有符号整型。 有符号整型最大支持64位，而无符号整型最大支持63位。对无符号整型的限制，是由于当前Redis协议不能在响应消息中返回64位无符号整数。 位和位偏移bitfield命令有两种方式来指定位偏移。如果未定带数字的前缀，将会以字符串的第0位作为起始位。 不过，如果偏移量带有#前缀，那么指定的偏移量需要乘以整型宽度，例如：1BITFIELD mystring SET i8 #0 100 i8 #1 200 将会在第1个i8整数的偏移0位和第2个整数的偏移8位进行设值。如果想得到一个给定长度的普通整型数组，则不一定要在客户端进行计算。 溢出控制使用OVERFLOW命令，用户可以通过指定下列其中一种行为来调整自增或自减操作溢出（或下溢）后的行为： WRAP: 回环算法，适用于有符号和无符号整型两种类型。对于无符号整型，回环计数将对整型最大值进行取模操作（C语言的标准行为）。对于有符号整型，上溢从最负的负数开始取数，下溢则从最大的正数开始取数，例如，如果i8整型的值设为127，自加1后的值变为-128。 SAT: 饱和算法，下溢之后设为最小的整型值，上溢之后设为最大的整数值。例如，i8整型的值从120开始加10后，结果是127，继续增加，结果还是保持为127。下溢也是同理，但量结果值将会保持在最负的负数值。 FAIL: 失败算法，这种模式下，在检测到上溢或下溢时，不做任何操作。相应的返回值会设为NULL，并返回给调用者。注意每种溢出（OVERFLOW）控制方法，仅影响紧跟在INCRBY命令后的子命令，直到重新指定溢出（OVERFLOW）控制方法。 如果没有指定溢出控制方法，默认情况下，将使用WRAP算法。123456789101112&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 11) (integer) 12) (integer) 1&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 11) (integer) 22) (integer) 2&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 11) (integer) 32) (integer) 3&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 11) (integer) 02) (integer) 3 BITFIELD命令能操作多字节位域，它会执行一系列操作，并返回一个响应数组，在参数列表中每个响应数组匹配相应的操作。 例如，下面的命令是对一个8位有符号整数偏移100位自增1，并获取4位无符号整数的值：123&gt; BITFIELD mykey INCRBY i5 100 1 GET u4 01) (integer) 12) (integer) 0 提示用GET指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，执行操作的结果会对缺失部分的位（bits）赋值为0。用SET或INCRBY指令对超出当前字符串长度的位（含key不存在的情况）进行寻址，将会扩展字符串并对扩展部分进行补0，扩展方式包括：按需扩展、按最小长度扩展和按最大寻址能力扩展。 返回值本命令返回一个针对子命令给定位置的处理结果组成的数组。OVERFLOW子命令在响应消息中，不会统计结果的条数。 下面是OVERFLOW FAIL返回NULL的样例：12&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 11) (nil) 动机（Motivations）本命令的动机是为了能够在单个大位图（large bitmap）中高效地存储多个小整数（或对键分成多个key，避免出现超大键），同时开放Redis提供的新使用案例，尤其是在实时分析领域。这种使用案例可以通过指定的溢出控制方法来支持。 性能考虑（Performance considerations）通常，BITFIELD是一个非常快的命令，但是注意，对短字符串的远地址（fat bits）寻址，将会比在存在的位执行命令更加耗时。 字节序（Orders of bits）BITFIELD命令使用的位图表现形式，可看作是从0位开始的，例如：把一个5位的无符号整数23，对一个所有位事先置0的位图，从第7位开始赋值，其结果如下所示：123+--------+--------+|00000001|01110000|+--------+--------+ 当偏移量和整型大小是字节边界对齐时，此时与大端模式（big endian）相同，但是，当字节边界未对齐时，那么理解字节序将变得非常重要。]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BITCOUNT]]></title>
    <url>%2Fredis%2F2018%2F05%2F08%2FBITCOUNT%2F</url>
    <content type="text"><![CDATA[BITCOUNT key [start end]解释统计字符串被设置为1的bit数. 一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。 start 和 end 参数的设置和 GETRANGE 命令类似，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推。 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 扩展 支持版本: &gt;= 2.6.0 时间复杂度: O(N) 返回值： Integers,被设置为 1 的位的数量。 redis-cli 例子12345678910redis&gt; SET testKey "foobar"OKredis&gt; BITCOUNT testKey(integer) 26redis&gt; BITCOUNT testKey 0 0(integer) 4redis&gt; BITCOUNT testKey 1 1(integer) 6redis&gt; DEL testKey(integer) 1 Spring Boot例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("testKey存在")void testKeyExist() &#123; // 测试的key final String testKey = String.format("keyNotExistTest_%s", UUID.randomUUID().toString()); RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer(); @SuppressWarnings("unchecked") final byte[] testKeySerializeBytes = keySerializer.serialize(testKey); try &#123; // testKey对应的value String value = "foobar"; stringRedisTemplate.opsForValue().set(testKey, value); logger.info("testKey is &#123;&#125; and set value is &#123;&#125;", testKey, value); // 由于stringRedisTemplate没提供bitCount方法 // 所以我们得绕一下，先获得到Connection对象，再通过Connection去调用bitCount Long bitCountAllValueResult = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null || testKeySerializeBytes == null) &#123; return -1L; &#125; return connection.bitCount(testKeySerializeBytes); &#125; &#125;); logger.info("bitCount all value result:&#123;&#125;", bitCountAllValueResult); Long bitCount0AND0ValueResult = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null || testKeySerializeBytes == null) &#123; return -1L; &#125; return connection.bitCount(testKeySerializeBytes, 0, 0); &#125; &#125;); logger.info("bitCount testKey 0 0 result:&#123;&#125;", bitCount0AND0ValueResult); Long bitCount1AND1ValueResult = stringRedisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(@Nullable RedisConnection connection) throws DataAccessException &#123; if (connection == null || testKeySerializeBytes == null) &#123; return -1L; &#125; return connection.bitCount(testKeySerializeBytes, 1, 1); &#125; &#125;); logger.info("bitCount testKey 1 1 result:&#123;&#125;", bitCount1AND1ValueResult); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APPEND]]></title>
    <url>%2Fredis%2F2018%2F05%2F07%2FAPPEND%2F</url>
    <content type="text"><![CDATA[APPEND key value解释如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。 扩展 支持版本: &gt;= 2.0.0 时间复杂度: O(1)。均摊时间复杂度是O(1)， 因为redis用的动态字符串的库在每次分配空间的时候会增加一倍的可用空闲空间，所以在添加的value较小而且已经存在的 value是任意大小的情况下，均摊时间复杂度是O(1) 。 返回值： Integers,返回append后字符串值（value）的长度。 redis-cli 例子12345678910redis&gt; EXISTS testKey(integer) 0redis&gt; APPEND testKey "Hello"(integer) 5redis&gt; APPEND testKey " World"(integer) 11redis&gt; GET testKey"Hello World"redis&gt; DEL testKey(integer) 1 Spring Boot例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private Logger logger = LoggerFactory.getLogger(getClass());@Resourceprivate StringRedisTemplate stringRedisTemplate;@Test@DisplayName("key不存在的情况")void keyNotExistTest() &#123; // 测试的key String testKey = String.format("keyNotExistTest_%s", UUID.randomUUID().toString()); try &#123; // 要append的值 String appendValue = "a"; logger.info("testKey is &#123;&#125;,the testKey is a random key ,so it not exist in redis", testKey); ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue(); Integer appendResult = stringStringValueOperations.append(testKey, appendValue); logger.info("testKey append is ok and result is &#123;&#125;", appendResult); String value = stringStringValueOperations.get(testKey); logger.info("keyNotExistTest,append value is:&#123;&#125;,result value is:&#123;&#125;", appendValue, value); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;@Test@DisplayName("key存在的情况")void keyExistTest() &#123; // 测试Key String testKey = String.format("keyExistTest_%s", UUID.randomUUID().toString()); try &#123; // testKey对应的原始值 String originalValue = "a"; // testKey要加的值 String appendValue = "b"; logger.info("testKey is &#123;&#125;", testKey); ValueOperations&lt;String, String&gt; stringStringValueOperations = stringRedisTemplate.opsForValue(); // 设置testKey一个值，因此testKey会存在与redis stringStringValueOperations.set(testKey, originalValue); logger.info("testKey set value is &#123;&#125;,so the key is exist in redis", originalValue); // 在testKey存在的情况下append Integer appendResult = stringStringValueOperations.append(testKey, appendValue); logger.info("testKey append ok and result is &#123;&#125;", appendResult); // append之后重新获得新的key对应的value String newValue = stringStringValueOperations.get(testKey); logger.info("after append testKey`s value is &#123;&#125;", newValue); &#125; finally &#123; // 最后删除这个key，避免产生大量无用数据 stringRedisTemplate.delete(testKey); &#125;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fredis%2F2018%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
